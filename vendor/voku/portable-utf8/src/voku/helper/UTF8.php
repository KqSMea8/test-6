<?php
 declare(strict_types=1); namespace voku\helper; final class UTF8 { const GRAPHEME_CLUSTER_RX = "(?:\r\n|(?:[ -~\x{200C}\x{200D}]|[ᆨ-ᇹ]+|[ᄀ-ᅟ]*(?:[가개갸걔거게겨계고과괘괴교구궈궤귀규그긔기까깨꺄꺠꺼께껴꼐꼬꽈꽤꾀꾜꾸꿔꿰뀌뀨끄끠끼나내냐냬너네녀녜노놔놰뇌뇨누눠눼뉘뉴느늬니다대댜댸더데뎌뎨도돠돼되됴두둬뒈뒤듀드듸디따때땨떄떠떼뗘뗴또똬뙈뙤뚀뚜뚸뛔뛰뜌뜨띄띠라래랴럐러레려례로롸뢔뢰료루뤄뤠뤼류르릐리마매먀먜머메며몌모뫄뫠뫼묘무뭐뭬뮈뮤므믜미바배뱌뱨버베벼볘보봐봬뵈뵤부붜붸뷔뷰브븨비빠빼뺘뺴뻐뻬뼈뼤뽀뽜뽸뾔뾰뿌뿨쀄쀠쀼쁘쁴삐사새샤섀서세셔셰소솨쇄쇠쇼수숴쉐쉬슈스싀시싸쌔쌰썌써쎄쎠쎼쏘쏴쐐쐬쑈쑤쒀쒜쒸쓔쓰씌씨아애야얘어에여예오와왜외요우워웨위유으의이자재쟈쟤저제져졔조좌좨죄죠주줘줴쥐쥬즈즤지짜째쨔쨰쩌쩨쪄쪠쪼쫘쫴쬐쬬쭈쭤쮀쮜쮸쯔쯰찌차채챠챼처체쳐쳬초촤쵀최쵸추춰췌취츄츠츼치카캐캬컈커케켜켸코콰쾌쾨쿄쿠쿼퀘퀴큐크킈키타태탸턔터테텨톄토톼퇘퇴툐투퉈퉤튀튜트틔티파패퍄퍠퍼페펴폐포퐈퐤푀표푸풔풰퓌퓨프픠피하해햐햬허헤혀혜호화홰회효후훠훼휘휴흐희히]?[ᅠ-ᆢ]+|[가-힣])[ᆨ-ᇹ]*|[ᄀ-ᅟ]+|[^\p{Cc}\p{Cf}\p{Zl}\p{Zp}])[\p{Mn}\p{Me}\x{09BE}\x{09D7}\x{0B3E}\x{0B57}\x{0BBE}\x{0BD7}\x{0CC2}\x{0CD5}\x{0CD6}\x{0D3E}\x{0D57}\x{0DCF}\x{0DDF}\x{200C}\x{200D}\x{1D165}\x{1D16E}-\x{1D172}]*|[\p{Cc}\p{Cf}\p{Zl}\p{Zp}])"; private static $BOM = [ "\xef\xbb\xbf" => 3, 'ï»¿' => 6, "\x00\x00\xfe\xff" => 4, '  þÿ' => 6, "\xff\xfe\x00\x00" => 4, 'ÿþ  ' => 6, "\xfe\xff" => 2, 'þÿ' => 4, "\xff\xfe" => 2, 'ÿþ' => 4, ]; private static $WHITESPACE = [ 0 => "\x0", 9 => "\x9", 10 => "\xa", 11 => "\xb", 13 => "\xd", 32 => "\x20", 160 => "\xc2\xa0", 5760 => "\xe1\x9a\x80", 6158 => "\xe1\xa0\x8e", 8192 => "\xe2\x80\x80", 8193 => "\xe2\x80\x81", 8194 => "\xe2\x80\x82", 8195 => "\xe2\x80\x83", 8196 => "\xe2\x80\x84", 8197 => "\xe2\x80\x85", 8198 => "\xe2\x80\x86", 8199 => "\xe2\x80\x87", 8200 => "\xe2\x80\x88", 8201 => "\xe2\x80\x89", 8202 => "\xe2\x80\x8a", 8232 => "\xe2\x80\xa8", 8233 => "\xe2\x80\xa9", 8239 => "\xe2\x80\xaf", 8287 => "\xe2\x81\x9f", 12288 => "\xe3\x80\x80", ]; private static $WHITESPACE_TABLE = [ 'SPACE' => "\x20", 'NO-BREAK SPACE' => "\xc2\xa0", 'OGHAM SPACE MARK' => "\xe1\x9a\x80", 'EN QUAD' => "\xe2\x80\x80", 'EM QUAD' => "\xe2\x80\x81", 'EN SPACE' => "\xe2\x80\x82", 'EM SPACE' => "\xe2\x80\x83", 'THREE-PER-EM SPACE' => "\xe2\x80\x84", 'FOUR-PER-EM SPACE' => "\xe2\x80\x85", 'SIX-PER-EM SPACE' => "\xe2\x80\x86", 'FIGURE SPACE' => "\xe2\x80\x87", 'PUNCTUATION SPACE' => "\xe2\x80\x88", 'THIN SPACE' => "\xe2\x80\x89", 'HAIR SPACE' => "\xe2\x80\x8a", 'LINE SEPARATOR' => "\xe2\x80\xa8", 'PARAGRAPH SEPARATOR' => "\xe2\x80\xa9", 'ZERO WIDTH SPACE' => "\xe2\x80\x8b", 'NARROW NO-BREAK SPACE' => "\xe2\x80\xaf", 'MEDIUM MATHEMATICAL SPACE' => "\xe2\x81\x9f", 'IDEOGRAPHIC SPACE' => "\xe3\x80\x80", ]; private static $BIDI_UNI_CODE_CONTROLS_TABLE = [ 8234 => "\xE2\x80\xAA", 8235 => "\xE2\x80\xAB", 8236 => "\xE2\x80\xAC", 8237 => "\xE2\x80\xAD", 8238 => "\xE2\x80\xAE", 8294 => "\xE2\x81\xA6", 8295 => "\xE2\x81\xA7", 8296 => "\xE2\x81\xA8", 8297 => "\xE2\x81\xA9", ]; private static $COMMON_CASE_FOLD = [ 'upper' => [ 'µ', 'ſ', "\xCD\x85", 'ς', 'ẞ', "\xCF\x90", "\xCF\x91", "\xCF\x95", "\xCF\x96", "\xCF\xB0", "\xCF\xB1", "\xCF\xB5", "\xE1\xBA\x9B", "\xE1\xBE\xBE", ], 'lower' => [ 'μ', 's', 'ι', 'σ', 'ß', 'β', 'θ', 'φ', 'π', 'κ', 'ρ', 'ε', "\xE1\xB9\xA1", 'ι', ], ]; private static $SUPPORT = []; private static $UTF8_MSWORD; private static $BROKEN_UTF8_FIX; private static $WIN1252_TO_UTF8; private static $ENCODINGS; private static $ORD; private static $CHR; public function __construct() { self::checkForSupport(); } public static function access(string $str, int $pos): string { if ('' === $str) { return ''; } if ($pos < 0) { return ''; } return (string)self::substr($str, $pos, 1); } public static function add_bom_to_string(string $str): string { if (self::string_has_bom($str) === false) { $str = self::bom() . $str; } return $str; } private static function apply_padding(string $str, int $left = 0, int $right = 0, string $padStr = ' ', string $encoding): string { $strlen = self::strlen($str, $encoding); if ($left && $right) { $length = ($left + $right) + $strlen; $type = STR_PAD_BOTH; } elseif ($left) { $length = $left + $strlen; $type = STR_PAD_LEFT; } elseif ($right) { $length = $right + $strlen; $type = STR_PAD_RIGHT; } else { $length = ($left + $right) + $strlen; $type = STR_PAD_BOTH; } return self::str_pad($str, $length, $padStr, $type, $encoding); } public static function array_change_key_case(array $array, int $case = CASE_LOWER): array { if ( $case !== CASE_LOWER && $case !== CASE_UPPER ) { $case = CASE_LOWER; } $return = []; foreach ($array as $key => $value) { if ($case === CASE_LOWER) { $key = self::strtolower($key); } else { $key = self::strtoupper($key); } $return[$key] = $value; } return $return; } public static function between(string $str, string $start, string $end, int $offset = 0, string $encoding = 'UTF-8'): string { $posStart = self::strpos($str, $start, $offset, $encoding); if ($posStart === false) { return ''; } $substrIndex = $posStart + self::strlen($start, $encoding); $posEnd = self::strpos($str, $end, $substrIndex, $encoding); if ( $posEnd === false || $posEnd === $substrIndex ) { return ''; } $return = self::substr($str, $substrIndex, $posEnd - $substrIndex, $encoding); if ($return === false) { return ''; } return $return; } public static function binary_to_str($bin): string { if (!isset($bin[0])) { return ''; } $convert = \base_convert($bin, 2, 16); if ($convert === '0') { return ''; } return \pack('H*', $convert); } public static function bom(): string { return "\xef\xbb\xbf"; } public static function callback($callback, string $str): array { return self::chr_map($callback, $str); } public static function char_at(string $str, int $index, string $encoding = 'UTF-8'): string { return (string)self::substr($str, $index, 1, $encoding); } public static function chars(string $str): array { return self::str_split($str, 1); } public static function checkForSupport() { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::$SUPPORT['already_checked_via_portable_utf8'] = true; self::$SUPPORT['mbstring'] = self::mbstring_loaded(); self::$SUPPORT['mbstring_func_overload'] = self::mbstring_overloaded(); self::$SUPPORT['iconv'] = self::iconv_loaded(); self::$SUPPORT['intl'] = self::intl_loaded(); self::$SUPPORT['intl__transliterator_list_ids'] = []; self::$SUPPORT['symfony_polyfill_used'] = self::symfony_polyfill_used(); if ( self::$SUPPORT['intl'] === true && \function_exists('transliterator_list_ids') === true ) { self::$SUPPORT['intl__transliterator_list_ids'] = \transliterator_list_ids(); } self::$SUPPORT['intlChar'] = self::intlChar_loaded(); self::$SUPPORT['ctype'] = self::ctype_loaded(); self::$SUPPORT['finfo'] = self::finfo_loaded(); self::$SUPPORT['json'] = self::json_loaded(); self::$SUPPORT['pcre_utf8'] = self::pcre_utf8_support(); } } public static function chr($code_point, string $encoding = 'UTF-8') { static $CHAR_CACHE = []; if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ( $encoding !== 'UTF-8' && $encoding !== 'ISO-8859-1' && $encoding !== 'WINDOWS-1252' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::chr() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } $cacheKey = $code_point . $encoding; if (isset($CHAR_CACHE[$cacheKey]) === true) { return $CHAR_CACHE[$cacheKey]; } if ($code_point <= 127) { if (self::$CHR === null) { $chrTmp = self::getData('chr'); if ($chrTmp) { self::$CHR = (array)$chrTmp; } } $chr = self::$CHR[$code_point]; if ($encoding !== 'UTF-8') { $chr = self::encode($encoding, $chr); } return $CHAR_CACHE[$cacheKey] = $chr; } if (self::$SUPPORT['intlChar'] === true) { $chr = \IntlChar::chr($code_point); if ($encoding !== 'UTF-8') { $chr = self::encode($encoding, $chr); } return $CHAR_CACHE[$cacheKey] = $chr; } if (self::$CHR === null) { $chrTmp = self::getData('chr'); if ($chrTmp) { self::$CHR = (array)$chrTmp; } } $code_point = (int)$code_point; if ($code_point <= 0x7F) { $chr = self::$CHR[$code_point]; } elseif ($code_point <= 0x7FF) { $chr = self::$CHR[($code_point >> 6) + 0xC0] . self::$CHR[($code_point & 0x3F) + 0x80]; } elseif ($code_point <= 0xFFFF) { $chr = self::$CHR[($code_point >> 12) + 0xE0] . self::$CHR[(($code_point >> 6) & 0x3F) + 0x80] . self::$CHR[($code_point & 0x3F) + 0x80]; } else { $chr = self::$CHR[($code_point >> 18) + 0xF0] . self::$CHR[(($code_point >> 12) & 0x3F) + 0x80] . self::$CHR[(($code_point >> 6) & 0x3F) + 0x80] . self::$CHR[($code_point & 0x3F) + 0x80]; } if ($encoding !== 'UTF-8') { $chr = self::encode($encoding, $chr); } return $CHAR_CACHE[$cacheKey] = $chr; } public static function chr_map($callback, string $str): array { $chars = self::split($str); return \array_map($callback, $chars); } public static function chr_size_list(string $str): array { if ('' === $str) { return []; } $strSplit = self::split($str); if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \array_map( function ($data) { return UTF8::strlen_in_byte($data); }, $strSplit ); } return \array_map('\strlen', $strSplit); } public static function chr_to_decimal(string $char): int { $code = self::ord($char[0]); $bytes = 1; if (!($code & 0x80)) { return $code; } if (($code & 0xe0) === 0xc0) { $bytes = 2; $code &= ~0xc0; } elseif (($code & 0xf0) === 0xe0) { $bytes = 3; $code &= ~0xe0; } elseif (($code & 0xf8) === 0xf0) { $bytes = 4; $code &= ~0xf0; } for ($i = 2; $i <= $bytes; $i++) { $code = ($code << 6) + (self::ord($char[$i - 1]) & ~0x80); } return $code; } public static function chr_to_hex($char, string $pfix = 'U+'): string { if ('' === $char) { return ''; } if ($char === '&#0;') { $char = ''; } return self::int_to_hex(self::ord($char), $pfix); } public static function chr_to_int(string $chr): int { return self::chr_to_decimal($chr); } public static function chunk_split(string $body, int $chunklen = 76, string $end = "\r\n"): string { return \implode($end, self::split($body, $chunklen)); } public static function clean( string $str, bool $remove_bom = false, bool $normalize_whitespace = false, bool $normalize_msword = false, bool $keep_non_breaking_space = false, bool $replace_diamond_question_mark = false, bool $remove_invisible_characters = true ): string { $regx = '/
      (
        (?: [\x00-\x7F]               # single-byte sequences   0xxxxxxx
        |   [\xC0-\xDF][\x80-\xBF]    # double-byte sequences   110xxxxx 10xxxxxx
        |   [\xE0-\xEF][\x80-\xBF]{2} # triple-byte sequences   1110xxxx 10xxxxxx * 2
        |   [\xF0-\xF7][\x80-\xBF]{3} # quadruple-byte sequence 11110xxx 10xxxxxx * 3
        ){1,100}                      # ...one or more times
      )
    | ( [\x80-\xBF] )                 # invalid byte in range 10000000 - 10111111
    | ( [\xC0-\xFF] )                 # invalid byte in range 11000000 - 11111111
    /x'; $str = (string)\preg_replace($regx, '$1', $str); if ($replace_diamond_question_mark === true) { $str = self::replace_diamond_question_mark($str, ''); } if ($remove_invisible_characters === true) { $str = self::remove_invisible_characters($str); } if ($normalize_whitespace === true) { $str = self::normalize_whitespace($str, $keep_non_breaking_space); } if ($normalize_msword === true) { $str = self::normalize_msword($str); } if ($remove_bom === true) { $str = self::remove_bom($str); } return $str; } public static function cleanup($str): string { $str = (string)$str; if ('' === $str) { return ''; } $str = self::fix_simple_utf8($str); $str = self::clean( $str, true, true, false, true, true, true ); return $str; } public static function codepoints($arg, bool $u_style = false): array { if (\is_string($arg) === true) { $arg = self::split($arg); } $arg = \array_map( [ self::class, 'ord', ], $arg ); if (\count($arg) === 0) { return []; } if ($u_style) { $arg = \array_map( [ self::class, 'int_to_hex', ], $arg ); } return $arg; } public static function collapse_whitespace(string $str): string { return self::trim( self::regex_replace($str, '[[:space:]]+', ' ') ); } public static function count_chars(string $str, bool $cleanUtf8 = false): array { return \array_count_values(self::split($str, 1, $cleanUtf8)); } public static function css_stripe_media_queries(string $str): string { return (string)\preg_replace( '#@media\\s+(?:only\\s)?(?:[\\s{\\(]|screen|all)\\s?[^{]+{.*}\\s*}\\s*#misU', '', $str ); } public static function ctype_loaded(): bool { return \extension_loaded('ctype'); } public static function decimal_to_chr($int): string { return self::html_entity_decode('&#' . $int . ';', ENT_QUOTES | ENT_HTML5); } public static function decode_mimeheader($str, $encoding = 'UTF-8') { if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['iconv'] === true) { return \iconv_mime_decode($str, ICONV_MIME_DECODE_CONTINUE_ON_ERROR, $encoding); } if ($encoding != 'UTF-8') { $str = self::encode($encoding, $str); } return \mb_decode_mimeheader($str); } public static function encode(string $toEncoding, string $str, bool $autodetectFromEncoding = true, string $fromEncoding = ''): string { if ('' === $str || '' === $toEncoding) { return $str; } if ($toEncoding !== 'UTF-8' && $toEncoding !== 'CP850') { $toEncoding = self::normalize_encoding($toEncoding, 'UTF-8'); } if ($fromEncoding && $fromEncoding !== 'UTF-8' && $fromEncoding !== 'CP850') { $fromEncoding = self::normalize_encoding($fromEncoding, null); } if ($toEncoding && $fromEncoding && $fromEncoding === $toEncoding) { return $str; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ($toEncoding === 'JSON') { return self::json_encode($str); } if ($fromEncoding === 'JSON') { $str = self::json_decode($str); $fromEncoding = ''; } if ($toEncoding === 'BASE64') { return base64_encode($str); } if ($fromEncoding === 'BASE64') { $str = base64_decode($str); $fromEncoding = ''; } if ($toEncoding === 'HTML-ENTITIES') { return self::html_encode($str, true, 'UTF-8'); } if ($fromEncoding === 'HTML-ENTITIES') { $str = self::html_decode($str, ENT_COMPAT, 'UTF-8'); $fromEncoding = ''; } $fromEncodingDetected = false; if ( $autodetectFromEncoding === true || !$fromEncoding ) { $fromEncodingDetected = self::str_detect_encoding($str); } if ($fromEncodingDetected !== false) { $fromEncoding = $fromEncodingDetected; } elseif ($fromEncodingDetected === false && $autodetectFromEncoding === true) { return self::to_utf8($str); } if ( !$fromEncoding || $fromEncoding === $toEncoding ) { return $str; } if ( $toEncoding === 'UTF-8' && ( $fromEncoding === 'WINDOWS-1252' || $fromEncoding === 'ISO-8859-1' ) ) { return self::to_utf8($str); } if ( $toEncoding === 'ISO-8859-1' && ( $fromEncoding === 'WINDOWS-1252' || $fromEncoding === 'UTF-8' ) ) { return self::to_iso8859($str); } if ( $toEncoding !== 'UTF-8' && $toEncoding !== 'ISO-8859-1' && $toEncoding !== 'WINDOWS-1252' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::encode() without mbstring cannot handle "' . $toEncoding . '" encoding', E_USER_WARNING); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $strEncoded = \mb_convert_encoding( $str, $toEncoding, $fromEncoding ); if ($strEncoded) { return $strEncoded; } } $return = \iconv($fromEncoding, $toEncoding, $str); if ($return !== false) { return $return; } return $str; } public static function encode_mimeheader( $str, $fromCharset = 'UTF-8', $toCharset = 'UTF-8', $transferEncoding = 'Q', $linefeed = "\r\n", $indent = 76 ) { if ($fromCharset !== 'UTF-8' && $fromCharset !== 'CP850') { $fromCharset = self::normalize_encoding($fromCharset, 'UTF-8'); } if ($toCharset !== 'UTF-8' && $toCharset !== 'CP850') { $toCharset = self::normalize_encoding($toCharset, 'UTF-8'); } $output = \iconv_mime_encode( '', $str, [ 'scheme' => $transferEncoding, 'line-length' => $indent, 'input-charset' => $fromCharset, 'output-charset' => $toCharset, 'line-break-chars' => $linefeed, ] ); return $output; } public static function extract_text(string $str, string $search = '', int $length = null, string $replacerForSkippedText = '…', string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } $trimChars = "\t\r\n -_()!~?=+/*\\,.:;\"'[]{}`&"; if ($length === null) { $length = (int)\round(self::strlen($str, $encoding) / 2, 0); } if (empty($search)) { $stringLength = self::strlen($str, $encoding); if ($length > 0) { $end = ($length - 1) > $stringLength ? $stringLength : ($length - 1); } else { $end = 0; } $pos = (int)\min( self::strpos($str, ' ', $end, $encoding), self::strpos($str, '.', $end, $encoding) ); if ($pos) { $strSub = self::substr($str, 0, $pos, $encoding); if ($strSub === false) { return ''; } return \rtrim($strSub, $trimChars) . $replacerForSkippedText; } return $str; } $wordPos = self::stripos($str, $search, 0, $encoding); $halfSide = (int)($wordPos - $length / 2 + self::strlen($search, $encoding) / 2); $pos_start = 0; if ($halfSide > 0) { $halfText = self::substr($str, 0, $halfSide, $encoding); if ($halfText !== false) { $pos_start = (int)\max( self::strrpos($halfText, ' ', 0, $encoding), self::strrpos($halfText, '.', 0, $encoding) ); } } if ($wordPos && $halfSide > 0) { $l = $pos_start + $length - 1; $realLength = self::strlen($str, $encoding); if ($l > $realLength) { $l = $realLength; } $pos_end = (int)\min( self::strpos($str, ' ', $l, $encoding), self::strpos($str, '.', $l, $encoding) ) - $pos_start; if (!$pos_end || $pos_end <= 0) { $strSub = self::substr($str, $pos_start, self::strlen($str), $encoding); if ($strSub !== false) { $extract = $replacerForSkippedText . \ltrim($strSub, $trimChars); } else { $extract = ''; } } else { $strSub = self::substr($str, $pos_start, $pos_end, $encoding); if ($strSub !== false) { $extract = $replacerForSkippedText . \trim($strSub, $trimChars) . $replacerForSkippedText; } else { $extract = ''; } } } else { $l = $length - 1; $trueLength = self::strlen($str, $encoding); if ($l > $trueLength) { $l = $trueLength; } $pos_end = \min( self::strpos($str, ' ', $l, $encoding), self::strpos($str, '.', $l, $encoding) ); if ($pos_end) { $strSub = self::substr($str, 0, $pos_end, $encoding); if ($strSub !== false) { $extract = \rtrim($strSub, $trimChars) . $replacerForSkippedText; } else { $extract = ''; } } else { $extract = $str; } } return $extract; } public static function file_get_contents( string $filename, bool $use_include_path = false, $context = null, int $offset = null, int $maxLength = null, int $timeout = 10, bool $convertToUtf8 = true, string $fromEncoding = '' ) { $filename = \filter_var($filename, FILTER_SANITIZE_STRING); if ($timeout && $context === null) { $context = \stream_context_create( [ 'http' => [ 'timeout' => $timeout, ], ] ); } if ($offset === null) { $offset = 0; } if (\is_int($maxLength) === true) { $data = \file_get_contents($filename, $use_include_path, $context, $offset, $maxLength); } else { $data = \file_get_contents($filename, $use_include_path, $context, $offset); } if ($data === false) { return false; } if ($convertToUtf8 === true) { if ( self::is_binary($data, true) === true && self::is_utf16($data, false) === false && self::is_utf32($data, false) === false ) { } else { $data = self::encode('UTF-8', $data, false, $fromEncoding); $data = self::cleanup($data); } } return $data; } public static function file_has_bom(string $file_path): bool { $file_content = \file_get_contents($file_path); if ($file_content === false) { throw new \RuntimeException('file_get_contents() returned false for:' . $file_path); } return self::string_has_bom($file_content); } public static function filter($var, int $normalization_form = 4 , string $leading_combining = '◌') { switch (\gettype($var)) { case 'array': foreach ($var as $k => $v) { $var[$k] = self::filter($v, $normalization_form, $leading_combining); } break; case 'object': foreach ($var as $k => $v) { $var->{$k} = self::filter($v, $normalization_form, $leading_combining); } break; case 'string': if (false !== \strpos($var, "\r")) { $var = self::normalize_line_ending($var); } if (self::is_ascii($var) === false) { if (\Normalizer::isNormalized($var, $normalization_form)) { $n = '-'; } else { $n = \Normalizer::normalize($var, $normalization_form); if (isset($n[0])) { $var = $n; } else { $var = self::encode('UTF-8', $var, true); } } if ( $var[0] >= "\x80" && isset($n[0], $leading_combining[0]) && \preg_match('/^\p{Mn}/u', $var) ) { $var = $leading_combining . $var; } } break; } return $var; } public static function filter_input(int $type, string $variable_name, int $filter = FILTER_DEFAULT, $options = null) { if (4 > \func_num_args()) { $var = \filter_input($type, $variable_name, $filter); } else { $var = \filter_input($type, $variable_name, $filter, $options); } return self::filter($var); } public static function filter_input_array(int $type, $definition = null, bool $add_empty = true) { if (2 > \func_num_args()) { $a = \filter_input_array($type); } else { $a = \filter_input_array($type, $definition, $add_empty); } return self::filter($a); } public static function filter_var($variable, int $filter = FILTER_DEFAULT, $options = null) { if (3 > \func_num_args()) { $variable = \filter_var($variable, $filter); } else { $variable = \filter_var($variable, $filter, $options); } return self::filter($variable); } public static function filter_var_array(array $data, $definition = null, bool $add_empty = true) { if (2 > \func_num_args()) { $a = \filter_var_array($data); } else { $a = \filter_var_array($data, $definition, $add_empty); } return self::filter($a); } public static function finfo_loaded(): bool { return \class_exists('finfo'); } public static function first_char(string $str, int $n = 1, string $encoding = 'UTF-8'): string { if ($n <= 0) { return ''; } $strSub = self::substr($str, 0, $n, $encoding); if ($strSub === false) { return ''; } return $strSub; } public static function fits_inside(string $str, int $box_size): bool { return (self::strlen($str) <= $box_size); } private static function fixStrCaseHelper(string $str, $useLower = false, $fullCaseFold = false): string { $upper = self::$COMMON_CASE_FOLD['upper']; $lower = self::$COMMON_CASE_FOLD['lower']; if ($useLower === true) { $str = (string)\str_replace( $upper, $lower, $str ); } else { $str = (string)\str_replace( $lower, $upper, $str ); } if ($fullCaseFold) { static $FULL_CASE_FOLD = null; if ($FULL_CASE_FOLD === null) { $FULL_CASE_FOLD = self::getData('caseFolding_full'); } if ($useLower === true) { $str = (string)\str_replace($FULL_CASE_FOLD[0], $FULL_CASE_FOLD[1], $str); } else { $str = (string)\str_replace($FULL_CASE_FOLD[1], $FULL_CASE_FOLD[0], $str); } } return $str; } public static function fix_simple_utf8(string $str): string { if ('' === $str) { return ''; } static $BROKEN_UTF8_TO_UTF8_KEYS_CACHE = null; static $BROKEN_UTF8_TO_UTF8_VALUES_CACHE = null; if ($BROKEN_UTF8_TO_UTF8_KEYS_CACHE === null) { if (self::$BROKEN_UTF8_FIX === null) { self::$BROKEN_UTF8_FIX = self::getData('utf8_fix'); } $BROKEN_UTF8_TO_UTF8_KEYS_CACHE = \array_keys(self::$BROKEN_UTF8_FIX); $BROKEN_UTF8_TO_UTF8_VALUES_CACHE = \array_values(self::$BROKEN_UTF8_FIX); } return \str_replace($BROKEN_UTF8_TO_UTF8_KEYS_CACHE, $BROKEN_UTF8_TO_UTF8_VALUES_CACHE, $str); } public static function fix_utf8($str) { if (\is_array($str) === true) { foreach ($str as $k => $v) { $str[$k] = self::fix_utf8($v); } return $str; } $str = (string)$str; $last = ''; while ($last !== $str) { $last = $str; $str = self::to_utf8( self::utf8_decode($str, true) ); } return $str; } public static function getCharDirection(string $char): string { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['intlChar'] === true) { $tmpReturn = \IntlChar::charDirection($char); $charDirection = [ 'RTL' => [1, 13, 14, 15, 21], 'LTR' => [0, 11, 12, 20], ]; if (\in_array($tmpReturn, $charDirection['LTR'], true)) { return 'LTR'; } if (\in_array($tmpReturn, $charDirection['RTL'], true)) { return 'RTL'; } } $c = static::chr_to_decimal($char); if (!(0x5be <= $c && 0x10b7f >= $c)) { return 'LTR'; } if (0x85e >= $c) { if (0x5be === $c || 0x5c0 === $c || 0x5c3 === $c || 0x5c6 === $c || (0x5d0 <= $c && 0x5ea >= $c) || (0x5f0 <= $c && 0x5f4 >= $c) || 0x608 === $c || 0x60b === $c || 0x60d === $c || 0x61b === $c || (0x61e <= $c && 0x64a >= $c) || (0x66d <= $c && 0x66f >= $c) || (0x671 <= $c && 0x6d5 >= $c) || (0x6e5 <= $c && 0x6e6 >= $c) || (0x6ee <= $c && 0x6ef >= $c) || (0x6fa <= $c && 0x70d >= $c) || 0x710 === $c || (0x712 <= $c && 0x72f >= $c) || (0x74d <= $c && 0x7a5 >= $c) || 0x7b1 === $c || (0x7c0 <= $c && 0x7ea >= $c) || (0x7f4 <= $c && 0x7f5 >= $c) || 0x7fa === $c || (0x800 <= $c && 0x815 >= $c) || 0x81a === $c || 0x824 === $c || 0x828 === $c || (0x830 <= $c && 0x83e >= $c) || (0x840 <= $c && 0x858 >= $c) || 0x85e === $c ) { return 'RTL'; } } elseif (0x200f === $c) { return 'RTL'; } elseif (0xfb1d <= $c) { if (0xfb1d === $c || (0xfb1f <= $c && 0xfb28 >= $c) || (0xfb2a <= $c && 0xfb36 >= $c) || (0xfb38 <= $c && 0xfb3c >= $c) || 0xfb3e === $c || (0xfb40 <= $c && 0xfb41 >= $c) || (0xfb43 <= $c && 0xfb44 >= $c) || (0xfb46 <= $c && 0xfbc1 >= $c) || (0xfbd3 <= $c && 0xfd3d >= $c) || (0xfd50 <= $c && 0xfd8f >= $c) || (0xfd92 <= $c && 0xfdc7 >= $c) || (0xfdf0 <= $c && 0xfdfc >= $c) || (0xfe70 <= $c && 0xfe74 >= $c) || (0xfe76 <= $c && 0xfefc >= $c) || (0x10800 <= $c && 0x10805 >= $c) || 0x10808 === $c || (0x1080a <= $c && 0x10835 >= $c) || (0x10837 <= $c && 0x10838 >= $c) || 0x1083c === $c || (0x1083f <= $c && 0x10855 >= $c) || (0x10857 <= $c && 0x1085f >= $c) || (0x10900 <= $c && 0x1091b >= $c) || (0x10920 <= $c && 0x10939 >= $c) || 0x1093f === $c || 0x10a00 === $c || (0x10a10 <= $c && 0x10a13 >= $c) || (0x10a15 <= $c && 0x10a17 >= $c) || (0x10a19 <= $c && 0x10a33 >= $c) || (0x10a40 <= $c && 0x10a47 >= $c) || (0x10a50 <= $c && 0x10a58 >= $c) || (0x10a60 <= $c && 0x10a7f >= $c) || (0x10b00 <= $c && 0x10b35 >= $c) || (0x10b40 <= $c && 0x10b55 >= $c) || (0x10b58 <= $c && 0x10b72 >= $c) || (0x10b78 <= $c && 0x10b7f >= $c) ) { return 'RTL'; } } return 'LTR'; } private static function getData(string $file) { $file = __DIR__ . '/data/' . $file . '.php'; if (\file_exists($file)) { return require $file; } return false; } public static function getSupportInfo(string $key = null) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ($key === null) { return self::$SUPPORT; } if (!isset(self::$SUPPORT[$key])) { return null; } return self::$SUPPORT[$key]; } private static function get_file_type( string $str, array $fallback = [ 'ext' => null, 'mime' => 'application/octet-stream', 'type' => null, ] ): array { if ($str === '') { return $fallback; } $str_info = self::substr_in_byte($str, 0, 2); if (self::strlen_in_byte($str_info) !== 2) { return $fallback; } $str_info = \unpack('C2chars', $str_info); $type_code = (int)($str_info['chars1'] . $str_info['chars2']); switch ($type_code) { case 3780: $ext = 'pdf'; $mime = 'application/pdf'; $type = 'binary'; break; case 7790: $ext = 'exe'; $mime = 'application/octet-stream'; $type = 'binary'; break; case 7784: $ext = 'midi'; $mime = 'audio/x-midi'; $type = 'binary'; break; case 8075: $ext = 'zip'; $mime = 'application/zip'; $type = 'binary'; break; case 8297: $ext = 'rar'; $mime = 'application/rar'; $type = 'binary'; break; case 255216: $ext = 'jpg'; $mime = 'image/jpeg'; $type = 'binary'; break; case 7173: $ext = 'gif'; $mime = 'image/gif'; $type = 'binary'; break; case 6677: $ext = 'bmp'; $mime = 'image/bmp'; $type = 'binary'; break; case 13780: $ext = 'png'; $mime = 'image/png'; $type = 'binary'; break; default: return $fallback; } return [ 'ext' => $ext, 'mime' => $mime, 'type' => $type, ]; } public static function get_random_string(int $length, string $possibleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', string $encoding = 'UTF-8'): string { $i = 0; $str = ''; $maxlength = self::strlen($possibleChars, $encoding); if ($maxlength === 0) { return ''; } while ($i < $length) { try { $randInt = \random_int(0, $maxlength - 1); } catch (\Exception $e) { $randInt = \mt_rand(0, $maxlength - 1); } $char = self::substr($possibleChars, $randInt, 1, $encoding); $str .= $char; $i++; } return $str; } public static function get_unique_string($entropyExtra = '', bool $md5 = true): string { $uniqueHelper = \mt_rand() . \session_id() . ($_SERVER['REMOTE_ADDR'] ?? '') . ($_SERVER['SERVER_ADDR'] ?? '') . $entropyExtra; $uniqueString = \uniqid($uniqueHelper, true); if ($md5) { $uniqueString = \md5($uniqueString . $uniqueHelper); } return $uniqueString; } public static function hasBom(string $str): bool { return self::string_has_bom($str); } public static function has_lowercase(string $str): bool { return self::str_matches_pattern($str, '.*[[:lower:]]'); } public static function has_uppercase(string $str): bool { return self::str_matches_pattern($str, '.*[[:upper:]]'); } public static function hex_to_chr(string $hexdec) { return self::decimal_to_chr(\hexdec($hexdec)); } public static function hex_to_int($hexDec) { $hexDec = (string)$hexDec; if ('' === $hexDec) { return false; } if (\preg_match('/^(?:\\\u|U\+|)([a-z0-9]{4,6})$/i', $hexDec, $match)) { return \intval($match[1], 16); } return false; } public static function html_decode(string $str, int $flags = null, string $encoding = 'UTF-8'): string { return self::html_entity_decode($str, $flags, $encoding); } public static function html_encode(string $str, bool $keepAsciiChars = false, string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $startCode = 0x00; if ($keepAsciiChars === true) { $startCode = 0x80; } return \mb_encode_numericentity( $str, [$startCode, 0xfffff, 0, 0xfffff, 0], $encoding ); } return \implode( '', \array_map( function ($chr) use ($keepAsciiChars, $encoding) { return UTF8::single_chr_html_encode($chr, $keepAsciiChars, $encoding); }, self::split($str) ) ); } public static function html_entity_decode(string $str, int $flags = null, string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } if (!isset($str[3])) { return $str; } if ( \strpos($str, '&') === false || ( \strpos($str, '&#') === false && \strpos($str, ';') === false ) ) { return $str; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($flags === null) { $flags = ENT_QUOTES | ENT_HTML5; } if ( $encoding !== 'UTF-8' && $encoding !== 'ISO-8859-1' && $encoding !== 'WINDOWS-1252' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::html_entity_decode() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } do { $str_compare = $str; if (self::$SUPPORT['mbstring'] === true) { $str = \mb_decode_numericentity( $str, [0x80, 0xfffff, 0, 0xfffff, 0], $encoding ); } else { $str = (string)\preg_replace_callback( "/&#\d{2,6};/", function ($matches) use ($encoding) { $returnTmp = \mb_convert_encoding($matches[0], $encoding, 'HTML-ENTITIES'); if ($returnTmp !== '"' && $returnTmp !== "'") { return $returnTmp; } return $matches[0]; }, $str ); } $str = \html_entity_decode( \preg_replace('/(&#(?:x0*[0-9a-f]{2,6}(?![0-9a-f;])|(?:0*\d{2,6}(?![0-9;]))))/iS', '$1;', $str), $flags, $encoding ); } while ($str_compare !== $str); return $str; } public static function html_escape(string $str, string $encoding = 'UTF-8'): string { return self::htmlspecialchars( $str, ENT_QUOTES | ENT_SUBSTITUTE, $encoding ); } public static function html_stripe_empty_tags(string $str): string { return (string)\preg_replace( "/<[^\/>]*>(([\s]?)*|)<\/[^>]*>/iu", '', $str ); } public static function htmlentities(string $str, int $flags = ENT_COMPAT, string $encoding = 'UTF-8', bool $double_encode = true): string { if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } $str = \htmlentities($str, $flags, $encoding, $double_encode); $str = \str_replace('\\', '&#92;', $str); return self::html_encode($str, true, $encoding); } public static function htmlspecialchars(string $str, int $flags = ENT_COMPAT, string $encoding = 'UTF-8', bool $double_encode = true): string { if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } return \htmlspecialchars($str, $flags, $encoding, $double_encode); } public static function iconv_loaded(): bool { return \extension_loaded('iconv') ? true : false; } public static function int_to_chr($int): string { return self::decimal_to_chr($int); } public static function int_to_hex(int $int, string $pfix = 'U+'): string { $hex = \dechex($int); $hex = (\strlen($hex) < 4 ? \substr('0000' . $hex, -4) : $hex); return $pfix . $hex . ''; } public static function intlChar_loaded(): bool { return \class_exists('IntlChar'); } public static function intl_loaded(): bool { return \extension_loaded('intl'); } public static function isAscii(string $str): bool { return self::is_ascii($str); } public static function isBase64($str): bool { return self::is_base64($str); } public static function isBinary($str, $strict = false): bool { return self::is_binary($str, $strict); } public static function isBom(string $utf8_chr): bool { return self::is_bom($utf8_chr); } public static function isHtml(string $str): bool { return self::is_html($str); } public static function isJson(string $str): bool { return self::is_json($str); } public static function isUtf16($str) { return self::is_utf16($str); } public static function isUtf32($str) { return self::is_utf32($str); } public static function isUtf8($str, $strict = false): bool { return self::is_utf8($str, $strict); } public static function is_alpha(string $str): bool { return self::str_matches_pattern($str, '^[[:alpha:]]*$'); } public static function is_alphanumeric(string $str): bool { return self::str_matches_pattern($str, '^[[:alnum:]]*$'); } public static function is_ascii(string $str): bool { if ('' === $str) { return true; } return !\preg_match('/[^\x09\x10\x13\x0A\x0D\x20-\x7E]/', $str); } public static function is_base64($str): bool { if ('' === $str) { return false; } if (\is_string($str) === false) { return false; } $base64String = (string)\base64_decode($str, true); return $base64String && \base64_encode($base64String) === $str; } public static function is_binary($input, bool $strict = false): bool { $input = (string)$input; if ('' === $input) { return false; } if (\preg_match('~^[01]+$~', $input)) { return true; } $ext = self::get_file_type($input); if ($ext['type'] === 'binary') { return true; } $testLength = self::strlen_in_byte($input); if ($testLength) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } $testNull = self::substr_count_in_byte($input, "\x0", 0, $testLength); if (($testNull / $testLength) > 0.256) { return true; } } if ($strict === true) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['finfo'] === false) { throw new \RuntimeException('ext-fileinfo: is not installed'); } $finfo = new \finfo(FILEINFO_MIME_ENCODING); $finfo_encoding = $finfo->buffer($input); if ($finfo_encoding && $finfo_encoding === 'binary') { return true; } } return false; } public static function is_binary_file($file): bool { $block = ''; $fp = \fopen($file, 'rb'); if (\is_resource($fp)) { $block = \fread($fp, 512); \fclose($fp); } if ($block === '') { return false; } return self::is_binary($block, true); } public static function is_blank(string $str): bool { return self::str_matches_pattern($str, '^[[:space:]]*$'); } public static function is_bom($str): bool { foreach (self::$BOM as $bomString => $bomByteLength) { if ($str === $bomString) { return true; } } return false; } public static function is_empty($str): bool { return empty($str); } public static function is_hexadecimal(string $str): bool { return self::str_matches_pattern($str, '^[[:xdigit:]]*$'); } public static function is_html(string $str): bool { if ('' === $str) { return false; } $matches = []; \preg_match("/<\/?\w+(?:(?:\s+\w+(?:\s*=\s*(?:\".*?\"|'.*?'|[^'\">\s]+))?)*+\s*|\s*)\/?>/", $str, $matches); return !(\count($matches) === 0); } public static function is_json(string $str): bool { if ('' === $str) { return false; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['json'] === false) { throw new \RuntimeException('ext-json: is not installed'); } $json = self::json_decode($str); return ( \is_object($json) === true || \is_array($json) === true ) && \json_last_error() === JSON_ERROR_NONE; } public static function is_lowercase(string $str): bool { if (self::str_matches_pattern($str, '^[[:lower:]]*$')) { return true; } return false; } public static function is_serialized(string $str): bool { if ('' === $str) { return false; } return $str === 'b:0;' || @\unserialize($str) !== false; } public static function is_uppercase(string $str): bool { return self::str_matches_pattern($str, '^[[:upper:]]*$'); } public static function is_utf16($str, $checkIfStringIsBinary = true) { $str = (string)$str; $strChars = []; if ( $checkIfStringIsBinary === true && self::is_binary($str, true) === false ) { return false; } if (self::$SUPPORT['mbstring'] === false) { \trigger_error('UTF8::is_utf16() without mbstring may did not work correctly', E_USER_WARNING); } $str = self::remove_bom($str); $maybeUTF16LE = 0; $test = \mb_convert_encoding($str, 'UTF-8', 'UTF-16LE'); if ($test) { $test2 = \mb_convert_encoding($test, 'UTF-16LE', 'UTF-8'); $test3 = \mb_convert_encoding($test2, 'UTF-8', 'UTF-16LE'); if ($test3 === $test) { if (\count($strChars) === 0) { $strChars = self::count_chars($str, true); } foreach (self::count_chars($test3, true) as $test3char => $test3charEmpty) { if (\in_array($test3char, $strChars, true) === true) { $maybeUTF16LE++; } } } } $maybeUTF16BE = 0; $test = \mb_convert_encoding($str, 'UTF-8', 'UTF-16BE'); if ($test) { $test2 = \mb_convert_encoding($test, 'UTF-16BE', 'UTF-8'); $test3 = \mb_convert_encoding($test2, 'UTF-8', 'UTF-16BE'); if ($test3 === $test) { if (\count($strChars) === 0) { $strChars = self::count_chars($str, true); } foreach (self::count_chars($test3, true) as $test3char => $test3charEmpty) { if (\in_array($test3char, $strChars, true) === true) { $maybeUTF16BE++; } } } } if ($maybeUTF16BE !== $maybeUTF16LE) { if ($maybeUTF16LE > $maybeUTF16BE) { return 1; } return 2; } return false; } public static function is_utf32($str, $checkIfStringIsBinary = true) { $str = (string)$str; $strChars = []; if ( $checkIfStringIsBinary === true && self::is_binary($str, true) === false ) { return false; } if (self::$SUPPORT['mbstring'] === false) { \trigger_error('UTF8::is_utf32() without mbstring may did not work correctly', E_USER_WARNING); } $str = self::remove_bom($str); $maybeUTF32LE = 0; $test = \mb_convert_encoding($str, 'UTF-8', 'UTF-32LE'); if ($test) { $test2 = \mb_convert_encoding($test, 'UTF-32LE', 'UTF-8'); $test3 = \mb_convert_encoding($test2, 'UTF-8', 'UTF-32LE'); if ($test3 === $test) { if (\count($strChars) === 0) { $strChars = self::count_chars($str, true); } foreach (self::count_chars($test3, true) as $test3char => $test3charEmpty) { if (\in_array($test3char, $strChars, true) === true) { $maybeUTF32LE++; } } } } $maybeUTF32BE = 0; $test = \mb_convert_encoding($str, 'UTF-8', 'UTF-32BE'); if ($test) { $test2 = \mb_convert_encoding($test, 'UTF-32BE', 'UTF-8'); $test3 = \mb_convert_encoding($test2, 'UTF-8', 'UTF-32BE'); if ($test3 === $test) { if (\count($strChars) === 0) { $strChars = self::count_chars($str, true); } foreach (self::count_chars($test3, true) as $test3char => $test3charEmpty) { if (\in_array($test3char, $strChars, true) === true) { $maybeUTF32BE++; } } } } if ($maybeUTF32BE !== $maybeUTF32LE) { if ($maybeUTF32LE > $maybeUTF32BE) { return 1; } return 2; } return false; } public static function is_utf8($str, bool $strict = false): bool { if (\is_array($str) === true) { foreach ($str as $k => $v) { if (false === self::is_utf8($v, $strict)) { return false; } } return true; } if ('' === $str) { return true; } if ($strict === true) { $isBinary = self::is_binary($str, true); if ($isBinary && self::is_utf16($str, false) !== false) { return false; } if ($isBinary && self::is_utf32($str, false) !== false) { return false; } } if (self::pcre_utf8_support() !== true) { return (\preg_match('/^.{1}/us', $str, $ar) === 1); } $mState = 0; $mUcs4 = 0; $mBytes = 1; if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$ORD === null) { self::$ORD = self::getData('ord'); } $len = self::strlen_in_byte((string)$str); for ($i = 0; $i < $len; $i++) { $in = self::$ORD[$str[$i]]; if ($mState === 0) { if (0 === (0x80 & $in)) { $mBytes = 1; } elseif (0xC0 === (0xE0 & $in)) { $mUcs4 = $in; $mUcs4 = ($mUcs4 & 0x1F) << 6; $mState = 1; $mBytes = 2; } elseif (0xE0 === (0xF0 & $in)) { $mUcs4 = $in; $mUcs4 = ($mUcs4 & 0x0F) << 12; $mState = 2; $mBytes = 3; } elseif (0xF0 === (0xF8 & $in)) { $mUcs4 = $in; $mUcs4 = ($mUcs4 & 0x07) << 18; $mState = 3; $mBytes = 4; } elseif (0xF8 === (0xFC & $in)) { $mUcs4 = $in; $mUcs4 = ($mUcs4 & 0x03) << 24; $mState = 4; $mBytes = 5; } elseif (0xFC === (0xFE & $in)) { $mUcs4 = $in; $mUcs4 = ($mUcs4 & 1) << 30; $mState = 5; $mBytes = 6; } else { return false; } } else { if (0x80 === (0xC0 & $in)) { $shift = ($mState - 1) * 6; $tmp = $in; $tmp = ($tmp & 0x0000003F) << $shift; $mUcs4 |= $tmp; if (0 === --$mState) { if ( (2 === $mBytes && $mUcs4 < 0x0080) || (3 === $mBytes && $mUcs4 < 0x0800) || (4 === $mBytes && $mUcs4 < 0x10000) || (4 < $mBytes) || (($mUcs4 & 0xFFFFF800) === 0xD800) || ($mUcs4 > 0x10FFFF) ) { return false; } $mState = 0; $mUcs4 = 0; $mBytes = 1; } } else { return false; } } } return true; } public static function json_decode(string $json, bool $assoc = false, int $depth = 512, int $options = 0) { $json = self::filter($json); if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['json'] === false) { throw new \RuntimeException('ext-json: is not installed'); } $json = \json_decode($json, $assoc, $depth, $options); return $json; } public static function json_encode($value, int $options = 0, int $depth = 512) { $value = self::filter($value); if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['json'] === false) { throw new \RuntimeException('ext-json: is not installed'); } $json = \json_encode($value, $options, $depth); return $json; } public static function json_loaded(): bool { return \function_exists('json_decode'); } public static function lcfirst(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { $strPartTwo = self::substr($str, 1, null, $encoding, $cleanUtf8); if ($strPartTwo === false) { $strPartTwo = ''; } $strPartOne = self::strtolower( (string)self::substr($str, 0, 1, $encoding, $cleanUtf8), $encoding, $cleanUtf8, $lang, $tryToKeepStringLength ); return $strPartOne . $strPartTwo; } public static function lcword( string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false ): string { return self::lcfirst($str, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } public static function lcwords( string $str, array $exceptions = [], string $charlist = '', string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false ): string { if (!$str) { return ''; } $words = self::str_to_words($str, $charlist); $newWords = []; if (\count($exceptions) > 0) { $useExceptions = true; } else { $useExceptions = false; } foreach ($words as $word) { if (!$word) { continue; } if ( $useExceptions === false || ( $useExceptions === true && !\in_array($word, $exceptions, true) ) ) { $word = self::lcfirst($word, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } $newWords[] = $word; } return \implode('', $newWords); } public static function lowerCaseFirst( string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false ): string { return self::lcfirst($str, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } public static function ltrim(string $str = '', $chars = INF): string { if ('' === $str) { return ''; } if ($chars === INF || !$chars) { $pattern = "^[\pZ\pC]+"; } else { $chars = \preg_quote($chars, '/'); $pattern = "^[$chars]+"; } return self::regex_replace($str, $pattern, '', '', '/'); } public static function max($arg) { if (\is_array($arg) === true) { $arg = \implode('', $arg); } $codepoints = self::codepoints($arg, false); if (\count($codepoints) === 0) { return null; } $codepoint_max = \max($codepoints); return self::chr($codepoint_max); } public static function max_chr_width(string $str): int { $bytes = self::chr_size_list($str); if (\count($bytes) > 0) { return (int)\max($bytes); } return 0; } public static function mbstring_loaded(): bool { $return = \extension_loaded('mbstring') ? true : false; if ($return === true) { \mb_internal_encoding('UTF-8'); } return $return; } private static function mbstring_overloaded(): bool { return \defined('MB_OVERLOAD_STRING') && (@\ini_get('mbstring.func_overload') & MB_OVERLOAD_STRING); } public static function min($arg) { if (\is_array($arg) === true) { $arg = \implode('', $arg); } $codepoints = self::codepoints($arg, false); if (\count($codepoints) === 0) { return null; } $codepoint_min = \min($codepoints); return self::chr($codepoint_min); } public static function normalizeEncoding($encoding, $fallback = '') { return self::normalize_encoding($encoding, $fallback); } public static function normalize_encoding($encoding, $fallback = '') { static $STATIC_NORMALIZE_ENCODING_CACHE = []; $encoding = (string)$encoding; if ( !$encoding || $encoding === '1' || $encoding === '0' ) { return $fallback; } if ( 'UTF-8' === $encoding || 'UTF8' === $encoding ) { return 'UTF-8'; } if ( '8BIT' === $encoding || 'BINARY' === $encoding ) { return 'CP850'; } if ( 'HTML' === $encoding || 'HTML-ENTITIES' === $encoding ) { return 'HTML-ENTITIES'; } if (isset($STATIC_NORMALIZE_ENCODING_CACHE[$encoding])) { return $STATIC_NORMALIZE_ENCODING_CACHE[$encoding]; } if (self::$ENCODINGS === null) { self::$ENCODINGS = self::getData('encodings'); } if (\in_array($encoding, self::$ENCODINGS, true)) { $STATIC_NORMALIZE_ENCODING_CACHE[$encoding] = $encoding; return $encoding; } $encodingOrig = $encoding; $encoding = \strtoupper($encoding); $encodingUpperHelper = \preg_replace('/[^a-zA-Z0-9\s]/', '', $encoding); $equivalences = [ 'ISO8859' => 'ISO-8859-1', 'ISO88591' => 'ISO-8859-1', 'ISO' => 'ISO-8859-1', 'LATIN' => 'ISO-8859-1', 'LATIN1' => 'ISO-8859-1', 'ISO88592' => 'ISO-8859-2', 'LATIN2' => 'ISO-8859-2', 'ISO88593' => 'ISO-8859-3', 'LATIN3' => 'ISO-8859-3', 'ISO88594' => 'ISO-8859-4', 'LATIN4' => 'ISO-8859-4', 'ISO88595' => 'ISO-8859-5', 'ISO88596' => 'ISO-8859-6', 'ISO88597' => 'ISO-8859-7', 'ISO88598' => 'ISO-8859-8', 'ISO88599' => 'ISO-8859-9', 'LATIN5' => 'ISO-8859-9', 'ISO885911' => 'ISO-8859-11', 'TIS620' => 'ISO-8859-11', 'ISO885910' => 'ISO-8859-10', 'LATIN6' => 'ISO-8859-10', 'ISO885913' => 'ISO-8859-13', 'LATIN7' => 'ISO-8859-13', 'ISO885914' => 'ISO-8859-14', 'LATIN8' => 'ISO-8859-14', 'ISO885915' => 'ISO-8859-15', 'LATIN9' => 'ISO-8859-15', 'ISO885916' => 'ISO-8859-16', 'LATIN10' => 'ISO-8859-16', 'CP1250' => 'WINDOWS-1250', 'WIN1250' => 'WINDOWS-1250', 'WINDOWS1250' => 'WINDOWS-1250', 'CP1251' => 'WINDOWS-1251', 'WIN1251' => 'WINDOWS-1251', 'WINDOWS1251' => 'WINDOWS-1251', 'CP1252' => 'WINDOWS-1252', 'WIN1252' => 'WINDOWS-1252', 'WINDOWS1252' => 'WINDOWS-1252', 'CP1253' => 'WINDOWS-1253', 'WIN1253' => 'WINDOWS-1253', 'WINDOWS1253' => 'WINDOWS-1253', 'CP1254' => 'WINDOWS-1254', 'WIN1254' => 'WINDOWS-1254', 'WINDOWS1254' => 'WINDOWS-1254', 'CP1255' => 'WINDOWS-1255', 'WIN1255' => 'WINDOWS-1255', 'WINDOWS1255' => 'WINDOWS-1255', 'CP1256' => 'WINDOWS-1256', 'WIN1256' => 'WINDOWS-1256', 'WINDOWS1256' => 'WINDOWS-1256', 'CP1257' => 'WINDOWS-1257', 'WIN1257' => 'WINDOWS-1257', 'WINDOWS1257' => 'WINDOWS-1257', 'CP1258' => 'WINDOWS-1258', 'WIN1258' => 'WINDOWS-1258', 'WINDOWS1258' => 'WINDOWS-1258', 'UTF16' => 'UTF-16', 'UTF32' => 'UTF-32', 'UTF8' => 'UTF-8', 'UTF' => 'UTF-8', 'UTF7' => 'UTF-7', '8BIT' => 'CP850', 'BINARY' => 'CP850', ]; if (!empty($equivalences[$encodingUpperHelper])) { $encoding = $equivalences[$encodingUpperHelper]; } $STATIC_NORMALIZE_ENCODING_CACHE[$encodingOrig] = $encoding; return $encoding; } public static function normalize_line_ending(string $str): string { return (string)str_replace(["\r\n", "\r"], "\n", $str); } public static function normalize_msword(string $str): string { if ('' === $str) { return ''; } static $UTF8_MSWORD_KEYS_CACHE = null; static $UTF8_MSWORD_VALUES_CACHE = null; if ($UTF8_MSWORD_KEYS_CACHE === null) { if (self::$UTF8_MSWORD === null) { self::$UTF8_MSWORD = self::getData('utf8_msword'); } $UTF8_MSWORD_KEYS_CACHE = \array_keys(self::$UTF8_MSWORD); $UTF8_MSWORD_VALUES_CACHE = \array_values(self::$UTF8_MSWORD); } return \str_replace($UTF8_MSWORD_KEYS_CACHE, $UTF8_MSWORD_VALUES_CACHE, $str); } public static function normalize_whitespace(string $str, bool $keepNonBreakingSpace = false, bool $keepBidiUnicodeControls = false): string { if ('' === $str) { return ''; } static $WHITESPACE_CACHE = []; $cacheKey = (int)$keepNonBreakingSpace; if (!isset($WHITESPACE_CACHE[$cacheKey])) { $WHITESPACE_CACHE[$cacheKey] = self::$WHITESPACE_TABLE; if ($keepNonBreakingSpace === true) { unset($WHITESPACE_CACHE[$cacheKey]['NO-BREAK SPACE']); } $WHITESPACE_CACHE[$cacheKey] = \array_values($WHITESPACE_CACHE[$cacheKey]); } if ($keepBidiUnicodeControls === false) { static $BIDI_UNICODE_CONTROLS_CACHE = null; if ($BIDI_UNICODE_CONTROLS_CACHE === null) { $BIDI_UNICODE_CONTROLS_CACHE = \array_values(self::$BIDI_UNI_CODE_CONTROLS_TABLE); } $str = \str_replace($BIDI_UNICODE_CONTROLS_CACHE, '', $str); } return \str_replace($WHITESPACE_CACHE[$cacheKey], ' ', $str); } public static function ord($chr, string $encoding = 'UTF-8'): int { $chr = (string)$chr; static $CHAR_CACHE = []; $chr_orig = $chr; if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); if ($encoding !== 'UTF-8') { $chr = self::encode($encoding, $chr); } } $cacheKey = $chr_orig . $encoding; if (isset($CHAR_CACHE[$cacheKey]) === true) { return $CHAR_CACHE[$cacheKey]; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['intlChar'] === true) { $code = \IntlChar::ord($chr); if ($code) { return $CHAR_CACHE[$cacheKey] = $code; } } $chr = \unpack('C*', (string)self::substr($chr, 0, 4, 'CP850')); $code = $chr ? $chr[1] : 0; if (0xF0 <= $code && isset($chr[4])) { return $CHAR_CACHE[$cacheKey] = (int)((($code - 0xF0) << 18) + (($chr[2] - 0x80) << 12) + (($chr[3] - 0x80) << 6) + $chr[4] - 0x80); } if (0xE0 <= $code && isset($chr[3])) { return $CHAR_CACHE[$cacheKey] = (int)((($code - 0xE0) << 12) + (($chr[2] - 0x80) << 6) + $chr[3] - 0x80); } if (0xC0 <= $code && isset($chr[2])) { return $CHAR_CACHE[$cacheKey] = (int)((($code - 0xC0) << 6) + $chr[2] - 0x80); } return $CHAR_CACHE[$cacheKey] = $code; } public static function parse_str(string $str, &$result, bool $cleanUtf8 = false): bool { if ($cleanUtf8 === true) { $str = self::clean($str); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $return = \mb_parse_str($str, $result); return !($return === false || empty($result)); } \parse_str($str, $result); return !empty($result); } public static function pcre_utf8_support(): bool { return (bool)@\preg_match('//u', ''); } public static function range($var1, $var2): array { if (!$var1 || !$var2) { return []; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['ctype'] === false) { throw new \RuntimeException('ext-ctype: is not installed'); } if (\ctype_digit((string)$var1)) { $start = (int)$var1; } elseif (\ctype_xdigit($var1)) { $start = (int)self::hex_to_int($var1); } else { $start = self::ord($var1); } if (!$start) { return []; } if (\ctype_digit((string)$var2)) { $end = (int)$var2; } elseif (\ctype_xdigit($var2)) { $end = (int)self::hex_to_int($var2); } else { $end = self::ord($var2); } if (!$end) { return []; } return \array_map( [ self::class, 'chr', ], \range($start, $end) ); } public static function rawurldecode(string $str, bool $multi_decode = true): string { if ('' === $str) { return ''; } $pattern = '/%u([0-9a-f]{3,4})/i'; if (\preg_match($pattern, $str)) { $str = (string)\preg_replace($pattern, '&#x\\1;', \rawurldecode($str)); } $flags = ENT_QUOTES | ENT_HTML5; do { $str_compare = $str; $str = self::fix_simple_utf8( \rawurldecode( self::html_entity_decode( self::to_utf8($str), $flags ) ) ); } while ($multi_decode === true && $str_compare !== $str); return $str; } private static function reduce_string_array(array $strings, bool $removeEmptyValues, int $removeShortValues = null): array { $return = []; foreach ($strings as $str) { if ( $removeShortValues !== null && self::strlen($str) <= $removeShortValues ) { continue; } if ( $removeEmptyValues === true && \trim($str) === '' ) { continue; } $return[] = $str; } return $return; } public static function regex_replace(string $str, string $pattern, string $replacement, string $options = '', string $delimiter = '/'): string { if ($options === 'msr') { $options = 'ms'; } if (!$delimiter) { $delimiter = '/'; } $str = (string)\preg_replace( $delimiter . $pattern . $delimiter . 'u' . $options, $replacement, $str ); return $str; } public static function removeBOM(string $str): string { return self::remove_bom($str); } public static function remove_bom(string $str): string { if ('' === $str) { return ''; } $strLength = self::strlen_in_byte($str); foreach (self::$BOM as $bomString => $bomByteLength) { if (0 === self::strpos_in_byte($str, $bomString, 0)) { $strTmp = self::substr_in_byte($str, $bomByteLength, $strLength); if ($strTmp === false) { return ''; } $strLength -= $bomByteLength; $str = (string)$strTmp; } } return $str; } public static function remove_duplicates(string $str, $what = ' '): string { if (\is_string($what) === true) { $what = [$what]; } if (\is_array($what) === true) { foreach ($what as $item) { $str = (string)\preg_replace('/(' . \preg_quote($item, '/') . ')+/', $item, $str); } } return $str; } public static function remove_html(string $str, string $allowableTags = ''): string { return \strip_tags($str, $allowableTags); } public static function remove_html_breaks(string $str, string $replacement = ''): string { return (string)\preg_replace("#/\r\n|\r|\n|<br.*/?>#isU", $replacement, $str); } public static function remove_invisible_characters(string $str, bool $url_encoded = true, string $replacement = ''): string { $non_displayables = []; if ($url_encoded) { $non_displayables[] = '/%0[0-8bcef]/'; $non_displayables[] = '/%1[0-9a-f]/'; } $non_displayables[] = '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+/S'; do { $str = (string)\preg_replace($non_displayables, $replacement, $str, -1, $count); } while ($count !== 0); return $str; } public static function remove_left(string $str, string $substring, string $encoding = 'UTF-8'): string { if (self::str_starts_with($str, $substring)) { return (string)self::substr( $str, self::strlen($substring, $encoding), null, $encoding ); } return $str; } public static function remove_right(string $str, string $substring, string $encoding = 'UTF-8'): string { if (self::str_ends_with($str, $substring)) { return (string)self::substr( $str, 0, self::strlen($str, $encoding) - self::strlen($substring, $encoding) ); } return $str; } public static function replace(string $str, string $search, string $replacement, bool $caseSensitive = true): string { if ($caseSensitive) { return self::str_replace($search, $replacement, $str); } return self::str_ireplace($search, $replacement, $str); } public static function replace_all(string $str, array $search, $replacement, bool $caseSensitive = true): string { if ($caseSensitive) { return self::str_replace($search, $replacement, $str); } return self::str_ireplace($search, $replacement, $str); } public static function replace_diamond_question_mark(string $str, string $replacementChar = '', bool $processInvalidUtf8 = true): string { if ('' === $str) { return ''; } if ($processInvalidUtf8 === true) { $replacementCharHelper = $replacementChar; if ($replacementChar === '') { $replacementCharHelper = 'none'; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === false) { $str = self::clean($str); } $save = \mb_substitute_character(); \mb_substitute_character($replacementCharHelper); $strTmp = \mb_convert_encoding($str, 'UTF-8', 'UTF-8'); \mb_substitute_character($save); if (\is_string($strTmp)) { $str = $strTmp; } else { $str = ''; } } return str_replace( [ "\xEF\xBF\xBD", '�', ], [ $replacementChar, $replacementChar, ], $str ); } public static function rtrim(string $str = '', $chars = INF): string { if ('' === $str) { return ''; } if ($chars === INF || !$chars) { $pattern = "[\pZ\pC]+\$"; } else { $chars = \preg_quote($chars, '/'); $pattern = "[$chars]+\$"; } return self::regex_replace($str, $pattern, '', '', '/'); } private static function rxClass(string $s, string $class = ''): string { static $RX_CLASSS_CACHE = []; $cacheKey = $s . $class; if (isset($RX_CLASSS_CACHE[$cacheKey])) { return $RX_CLASSS_CACHE[$cacheKey]; } $class = [$class]; foreach (self::str_split($s) as $s) { if ('-' === $s) { $class[0] = '-' . $class[0]; } elseif (!isset($s[2])) { $class[0] .= \preg_quote($s, '/'); } elseif (1 === self::strlen($s)) { $class[0] .= $s; } else { $class[] = $s; } } if ($class[0]) { $class[0] = '[' . $class[0] . ']'; } if (1 === \count($class)) { $return = $class[0]; } else { $return = '(?:' . \implode('|', $class) . ')'; } $RX_CLASSS_CACHE[$cacheKey] = $return; return $return; } public static function showSupport() { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } echo '<pre>'; foreach (self::$SUPPORT as $key => $value) { echo $key . ' - ' . \print_r($value, true) . "\n<br>"; } echo '</pre>'; } public static function single_chr_html_encode(string $char, bool $keepAsciiChars = false, string $encoding = 'UTF-8'): string { if ('' === $char) { return ''; } if ( $keepAsciiChars === true && self::is_ascii($char) === true ) { return $char; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } return '&#' . self::ord($char, $encoding) . ';'; } public static function spaces_to_tabs(string $str, int $tabLength = 4): string { return \str_replace(\str_repeat(' ', $tabLength), "\t", $str); } public static function split($str, int $length = 1, bool $cleanUtf8 = false): array { if ($length <= 0) { return []; } if (\is_array($str) === true) { foreach ($str as $k => $v) { $str[$k] = self::split($v, $length); } return $str; } $str = (string)$str; if ('' === $str) { return []; } $ret = []; if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ($cleanUtf8 === true) { $str = self::clean($str); } if (self::$SUPPORT['pcre_utf8'] === true) { \preg_match_all('/./us', $str, $retArray); if (isset($retArray[0])) { $ret = $retArray[0]; } unset($retArray); } else { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } $len = self::strlen_in_byte($str); for ($i = 0; $i < $len; $i++) { if (($str[$i] & "\x80") === "\x00") { $ret[] = $str[$i]; } elseif ( isset($str[$i + 1]) && ($str[$i] & "\xE0") === "\xC0" ) { if (($str[$i + 1] & "\xC0") === "\x80") { $ret[] = $str[$i] . $str[$i + 1]; $i++; } } elseif ( isset($str[$i + 2]) && ($str[$i] & "\xF0") === "\xE0" ) { if ( ($str[$i + 1] & "\xC0") === "\x80" && ($str[$i + 2] & "\xC0") === "\x80" ) { $ret[] = $str[$i] . $str[$i + 1] . $str[$i + 2]; $i += 2; } } elseif ( isset($str[$i + 3]) && ($str[$i] & "\xF8") === "\xF0" ) { if ( ($str[$i + 1] & "\xC0") === "\x80" && ($str[$i + 2] & "\xC0") === "\x80" && ($str[$i + 3] & "\xC0") === "\x80" ) { $ret[] = $str[$i] . $str[$i + 1] . $str[$i + 2] . $str[$i + 3]; $i += 3; } } } } if ($length > 1) { $ret = \array_chunk($ret, $length); return \array_map( function ($item) { return \implode('', $item); }, $ret ); } if (isset($ret[0]) && $ret[0] === '') { return []; } return $ret; } public static function str_camelize(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { $str = self::lcfirst(self::trim($str), $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); $str = (string)\preg_replace('/^[-_]+/', '', $str); $str = (string)\preg_replace_callback( '/[-_\s]+(.)?/u', function ($match) use ($encoding, $cleanUtf8, $lang, $tryToKeepStringLength) { if (isset($match[1])) { return UTF8::strtoupper($match[1], $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } return ''; }, $str ); $str = (string)\preg_replace_callback( '/[\d]+(.)?/u', function ($match) use ($encoding, $cleanUtf8, $lang, $tryToKeepStringLength) { return UTF8::strtoupper($match[0], $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); }, $str ); return $str; } public static function str_capitalize_name(string $str): string { $str = self::collapse_whitespace($str); $str = self::str_capitalize_name_helper($str, ' '); $str = self::str_capitalize_name_helper($str, '-'); return $str; } private static function str_capitalize_name_helper(string $names, string $delimiter, string $encoding = 'UTF-8'): string { $namesArray = \explode($delimiter, $names); if ($namesArray === false) { return ''; } $specialCases = [ 'names' => [ 'ab', 'af', 'al', 'and', 'ap', 'bint', 'binte', 'da', 'de', 'del', 'den', 'der', 'di', 'dit', 'ibn', 'la', 'mac', 'nic', 'of', 'ter', 'the', 'und', 'van', 'von', 'y', 'zu', ], 'prefixes' => [ 'al-', "d'", 'ff', "l'", 'mac', 'mc', 'nic', ], ]; foreach ($namesArray as &$name) { if (\in_array($name, $specialCases['names'], true)) { continue; } $continue = false; if ($delimiter == '-') { foreach ($specialCases['names'] as $beginning) { if (self::strpos($name, $beginning, 0, $encoding) === 0) { $continue = true; } } } foreach ($specialCases['prefixes'] as $beginning) { if (self::strpos($name, $beginning, 0, $encoding) === 0) { $continue = true; } } if ($continue) { continue; } $name = self::str_upper_first($name); } return \implode($delimiter, $namesArray); } public static function str_contains(string $haystack, string $needle, $caseSensitive = true, string $encoding = 'UTF-8'): bool { if ('' === $haystack || '' === $needle) { return false; } if ($caseSensitive !== false && $caseSensitive !== true) { $encoding = (string)$caseSensitive; } if ($caseSensitive) { return (self::strpos($haystack, $needle, 0, $encoding) !== false); } return (self::stripos($haystack, $needle, 0, $encoding) !== false); } public static function str_contains_all(string $haystack, array $needles, $caseSensitive = true, string $encoding = 'UTF-8'): bool { if ('' === $haystack) { return false; } if (empty($needles)) { return false; } if ($caseSensitive !== false && $caseSensitive !== true) { $encoding = (string)$caseSensitive; } foreach ($needles as $needle) { if (!self::str_contains($haystack, $needle, $caseSensitive, $encoding)) { return false; } } return true; } public static function str_contains_any(string $haystack, array $needles, $caseSensitive = true, string $encoding = 'UTF-8'): bool { if (empty($needles)) { return false; } foreach ($needles as $needle) { if (self::str_contains($haystack, $needle, $caseSensitive, $encoding)) { return true; } } return false; } public static function str_dasherize(string $str, string $encoding = 'UTF-8'): string { return self::str_delimit($str, '-', $encoding); } public static function str_delimit(string $str, string $delimiter, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { $str = self::trim($str); $str = (string)\preg_replace('/\B([A-Z])/u', '-\1', $str); $str = self::strtolower($str, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); return (string)\preg_replace('/[-_\s]+/u', $delimiter, $str); } public static function str_detect_encoding($str) { $str = (string)$str; if (self::is_binary($str, true) === true) { $isUtf16 = self::is_utf16($str, false); if ($isUtf16 === 1) { return 'UTF-16LE'; } if ($isUtf16 === 2) { return 'UTF-16BE'; } $isUtf32 = self::is_utf32($str, false); if ($isUtf32 === 1) { return 'UTF-32LE'; } if ($isUtf32 === 2) { return 'UTF-32BE'; } return false; } if (self::is_ascii($str) === true) { return 'ASCII'; } if (self::is_utf8($str) === true) { return 'UTF-8'; } $detectOrder = [ 'ISO-8859-1', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4', 'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8', 'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'ISO-8859-16', 'WINDOWS-1251', 'WINDOWS-1252', 'WINDOWS-1254', 'CP932', 'CP936', 'CP950', 'CP866', 'CP850', 'CP51932', 'CP50220', 'CP50221', 'CP50222', 'ISO-2022-JP', 'ISO-2022-KR', 'JIS', 'JIS-ms', 'EUC-CN', 'EUC-JP', ]; if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $encoding = \mb_detect_encoding($str, $detectOrder, true); if ($encoding) { return $encoding; } } if (self::$ENCODINGS === null) { self::$ENCODINGS = self::getData('encodings'); } foreach (self::$ENCODINGS as $encodingTmp) { if ((string)@\iconv($encodingTmp, $encodingTmp . '//IGNORE', $str) === $str) { return $encodingTmp; } } return false; } public static function str_ends_with(string $haystack, string $needle): bool { if ('' === $haystack || '' === $needle) { return false; } return \substr($haystack, -\strlen($needle)) === $needle; } public static function str_ends_with_any(string $str, array $substrings): bool { if (empty($substrings)) { return false; } foreach ($substrings as $substring) { if (self::str_ends_with($str, $substring)) { return true; } } return false; } public static function str_ensure_left(string $str, string $substring): string { if (!self::str_starts_with($str, $substring)) { $str = $substring . $str; } return $str; } public static function str_ensure_right(string $str, string $substring): string { if (!self::str_ends_with($str, $substring)) { $str .= $substring; } return $str; } public static function str_humanize($str): string { $str = self::str_replace( [ '_id', '_', ], [ '', ' ', ], $str ); return self::ucfirst(self::trim($str)); } public static function str_iends_with(string $haystack, string $needle): bool { if ('' === $haystack || '' === $needle) { return false; } if (self::strcasecmp(\substr($haystack, -\strlen($needle)), $needle) === 0) { return true; } return false; } public static function str_iends_with_any(string $str, array $substrings): bool { if (empty($substrings)) { return false; } foreach ($substrings as $substring) { if (self::str_iends_with($str, $substring)) { return true; } } return false; } public static function str_iindex_first(string $str, string $needle, int $offset = 0, string $encoding = 'UTF-8') { return self::stripos( $str, $needle, $offset, $encoding ); } public static function str_iindex_last(string $str, string $needle, int $offset = 0, string $encoding = 'UTF-8') { return self::strripos( $str, $needle, $offset, $encoding ); } public static function str_index_first(string $str, string $needle, int $offset = 0, string $encoding = 'UTF-8') { return self::strpos( $str, $needle, $offset, $encoding ); } public static function str_index_last(string $str, string $needle, int $offset = 0, string $encoding = 'UTF-8') { return self::strrpos( $str, $needle, $offset, $encoding ); } public static function str_insert(string $str, string $substring, int $index, string $encoding = 'UTF-8'): string { $len = self::strlen($str, $encoding); if ($index > $len) { return $str; } $start = self::substr($str, 0, $index, $encoding); $end = self::substr($str, $index, $len, $encoding); return $start . $substring . $end; } public static function str_ireplace($search, $replace, $subject, &$count = null) { $search = (array)$search; foreach ($search as &$s) { if ('' === $s .= '') { $s = '/^(?<=.)$/'; } else { $s = '/' . \preg_quote($s, '/') . '/ui'; } } $subject = \preg_replace($search, $replace, $subject, -1, $replace); $count = $replace; return $subject; } public static function str_istarts_with(string $haystack, string $needle): bool { if ('' === $haystack || '' === $needle) { return false; } if (self::stripos($haystack, $needle) === 0) { return true; } return false; } public static function str_istarts_with_any(string $str, array $substrings): bool { if ('' === $str) { return false; } if (empty($substrings)) { return false; } foreach ($substrings as $substring) { if (self::str_istarts_with($str, $substring)) { return true; } } return false; } public static function str_isubstr_after_first_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_iindex_first($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, $offset + self::strlen($separator, $encoding), null, $encoding ); } public static function str_isubstr_after_last_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_iindex_last($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, $offset + self::strlen($separator, $encoding), null, $encoding ); } public static function str_isubstr_before_first_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_iindex_first($str, $separator); if ($offset === false) { return ''; } return (string)self::substr($str, 0, $offset, $encoding); } public static function str_isubstr_before_last_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_iindex_last($str, $separator); if ($offset === false) { return ''; } return (string)self::substr($str, 0, $offset, $encoding); } public static function str_isubstr_first(string $str, string $needle, bool $beforeNeedle = false, string $encoding = 'UTF-8'): string { if ( '' === $needle || '' === $str ) { return ''; } $part = self::stristr( $str, $needle, $beforeNeedle, $encoding ); if (false === $part) { return ''; } return $part; } public static function str_isubstr_last(string $str, string $needle, bool $beforeNeedle = false, string $encoding = 'UTF-8'): string { if ( '' === $needle || '' === $str ) { return ''; } $part = self::strrichr($str, $needle, $beforeNeedle, $encoding); if (false === $part) { return ''; } return $part; } public static function str_last_char(string $str, int $n = 1, string $encoding = 'UTF-8'): string { if ($n <= 0) { return ''; } $returnTmp = self::substr($str, -$n, null, $encoding); return ($returnTmp === false ? '' : $returnTmp); } public static function str_limit(string $str, int $length = 100, string $strAddOn = '…', string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } if ($length <= 0) { return ''; } if (self::strlen($str, $encoding) <= $length) { return $str; } return self::substr($str, 0, $length - self::strlen($strAddOn), $encoding) . $strAddOn; } public static function str_limit_after_word(string $str, int $length = 100, string $strAddOn = '…', string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } if ($length <= 0) { return ''; } if (self::strlen($str, $encoding) <= $length) { return $str; } if (self::substr($str, $length - 1, 1, $encoding) === ' ') { return self::substr($str, 0, $length - 1, $encoding) . $strAddOn; } $str = (string)self::substr($str, 0, $length, $encoding); $array = \explode(' ', $str); \array_pop($array); $new_str = \implode(' ', $array); if ($new_str === '') { $str = self::substr($str, 0, $length - 1, $encoding) . $strAddOn; } else { $str = $new_str . $strAddOn; } return $str; } public static function str_longest_common_prefix(string $str, string $otherStr, string $encoding = 'UTF-8'): string { $maxLength = \min(self::strlen($str, $encoding), self::strlen($otherStr, $encoding)); $longestCommonPrefix = ''; for ($i = 0; $i < $maxLength; $i++) { $char = self::substr($str, $i, 1, $encoding); if ($char == self::substr($otherStr, $i, 1, $encoding)) { $longestCommonPrefix .= $char; } else { break; } } return $longestCommonPrefix; } public static function str_longest_common_substring(string $str, string $otherStr, string $encoding = 'UTF-8'): string { $strLength = self::strlen($str, $encoding); $otherLength = self::strlen($otherStr, $encoding); if ($strLength == 0 || $otherLength == 0) { return ''; } $len = 0; $end = 0; $table = \array_fill( 0, $strLength + 1, \array_fill(0, $otherLength + 1, 0) ); for ($i = 1; $i <= $strLength; $i++) { for ($j = 1; $j <= $otherLength; $j++) { $strChar = self::substr($str, $i - 1, 1, $encoding); $otherChar = self::substr($otherStr, $j - 1, 1, $encoding); if ($strChar == $otherChar) { $table[$i][$j] = $table[$i - 1][$j - 1] + 1; if ($table[$i][$j] > $len) { $len = $table[$i][$j]; $end = $i; } } else { $table[$i][$j] = 0; } } } $returnTmp = self::substr($str, $end - $len, $len, $encoding); return ($returnTmp === false ? '' : $returnTmp); } public static function str_longest_common_suffix(string $str, string $otherStr, string $encoding = 'UTF-8'): string { $maxLength = \min(self::strlen($str, $encoding), self::strlen($otherStr, $encoding)); $longestCommonSuffix = ''; for ($i = 1; $i <= $maxLength; $i++) { $char = self::substr($str, -$i, 1, $encoding); if ($char == self::substr($otherStr, -$i, 1, $encoding)) { $longestCommonSuffix = $char . $longestCommonSuffix; } else { break; } } return $longestCommonSuffix; } public static function str_matches_pattern(string $str, string $pattern): bool { if (\preg_match('/' . $pattern . '/u', $str)) { return true; } return false; } public static function str_offset_exists(string $str, int $offset, string $encoding = 'UTF-8'): bool { $length = self::strlen($str, $encoding); if ($offset >= 0) { return ($length > $offset); } return ($length >= \abs($offset)); } public static function str_offset_get(string $str, int $index, string $encoding = 'UTF-8'): string { $length = self::strlen($str); if ( ($index >= 0 && $length <= $index) || $length < \abs($index) ) { throw new \OutOfBoundsException('No character exists at the index'); } return self::char_at($str, $index, $encoding); } public static function str_pad(string $str, int $pad_length, string $pad_string = ' ', $pad_type = STR_PAD_RIGHT, string $encoding = 'UTF-8'): string { if ('' === $str) { return ''; } if ($pad_type !== (int)$pad_type) { if ($pad_type == 'left') { $pad_type = STR_PAD_LEFT; } elseif ($pad_type == 'right') { $pad_type = STR_PAD_RIGHT; } elseif ($pad_type == 'both') { $pad_type = STR_PAD_BOTH; } else { throw new \InvalidArgumentException( 'Pad expects $padType to be "STR_PAD_*" or ' . "to be one of 'left', 'right' or 'both'" ); } } $str_length = self::strlen($str, $encoding); if ( $pad_length > 0 && $pad_length >= $str_length ) { $ps_length = self::strlen($pad_string, $encoding); $diff = ($pad_length - $str_length); switch ($pad_type) { case STR_PAD_LEFT: $pre = \str_repeat($pad_string, (int)\ceil($diff / $ps_length)); $pre = (string)self::substr($pre, 0, $diff, $encoding); $post = ''; break; case STR_PAD_BOTH: $pre = \str_repeat($pad_string, (int)\ceil($diff / $ps_length / 2)); $pre = (string)self::substr($pre, 0, (int)\floor($diff / 2), $encoding); $post = \str_repeat($pad_string, (int)\ceil($diff / $ps_length / 2)); $post = (string)self::substr($post, 0, (int)\ceil($diff / 2), $encoding); break; case STR_PAD_RIGHT: default: $post = \str_repeat($pad_string, (int)\ceil($diff / $ps_length)); $post = (string)self::substr($post, 0, $diff, $encoding); $pre = ''; } return $pre . $str . $post; } return $str; } public static function str_pad_both(string $str, int $length, string $padStr = ' ', string $encoding = 'UTF-8'): string { $padding = $length - self::strlen($str, $encoding); return self::apply_padding($str, (int)\floor($padding / 2), (int)\ceil($padding / 2), $padStr, $encoding); } public static function str_pad_left(string $str, int $length, string $padStr = ' ', string $encoding = 'UTF-8'): string { return self::apply_padding($str, $length - self::strlen($str), 0, $padStr, $encoding); } public static function str_pad_right(string $str, int $length, string $padStr = ' ', string $encoding = 'UTF-8'): string { return self::apply_padding($str, 0, $length - self::strlen($str), $padStr, $encoding); } public static function str_repeat(string $str, int $multiplier): string { $str = self::filter($str); return \str_repeat($str, $multiplier); } public static function str_replace($search, $replace, $subject, int &$count = null) { return \str_replace($search, $replace, $subject, $count); } public static function str_replace_beginning(string $str, string $search, string $replacement): string { return self::regex_replace( $str, '^' . \preg_quote($search, '/'), self::str_replace('\\', '\\\\', $replacement) ); } public static function str_replace_ending(string $str, string $search, string $replacement): string { return self::regex_replace( $str, \preg_quote($search, '/') . '$', self::str_replace('\\', '\\\\', $replacement) ); } public static function str_replace_first(string $search, string $replace, string $subject): string { $pos = self::strpos($subject, $search); if ($pos !== false) { return self::substr_replace($subject, $replace, $pos, self::strlen($search)); } return $subject; } public static function str_replace_last(string $search, string $replace, string $subject): string { $pos = self::strrpos($subject, $search); if ($pos !== false) { return self::substr_replace($subject, $replace, $pos, self::strlen($search)); } return $subject; } public static function str_shuffle(string $str): string { $indexes = \range(0, self::strlen($str) - 1); \shuffle($indexes); $shuffledStr = ''; foreach ($indexes as $i) { $shuffledStr .= self::substr($str, $i, 1); } return $shuffledStr; } public static function str_slice(string $str, int $start, int $end = null, string $encoding = 'UTF-8') { if ($end === null) { $length = self::strlen($str); } elseif ($end >= 0 && $end <= $start) { return ''; } elseif ($end < 0) { $length = self::strlen($str) + $end - $start; } else { $length = $end - $start; } return self::substr($str, $start, $length, $encoding); } public static function str_snakeize(string $str, string $encoding = 'UTF-8'): string { $str = self::normalize_whitespace($str); $str = \str_replace('-', '_', $str); $str = (string)\preg_replace_callback( '/([\d|A-Z])/u', function ($matches) use ($encoding) { $match = $matches[1]; $matchInt = (int)$match; if ((string)$matchInt == $match) { return '_' . $match . '_'; } return '_' . UTF8::strtolower($match, $encoding); }, $str ); $str = (string)\preg_replace( [ '/\s+/', '/^\s+|\s+$/', '/_+/', ], [ '_', '', '_', ], $str ); $str = self::trim($str, '_'); $str = self::trim($str); return $str; } public static function str_sort(string $str, bool $unique = false, bool $desc = false): string { $array = self::codepoints($str); if ($unique) { $array = \array_flip(\array_flip($array)); } if ($desc) { \arsort($array); } else { \asort($array); } return self::string($array); } public static function str_split($str, int $len = 1): array { return self::split($str, $len); } public static function str_split_pattern(string $str, string $pattern, int $limit = -1): array { if ($limit === 0) { return []; } if ($pattern === '') { return [$str]; } if ($limit > 0) { ++$limit; } else { $limit = -1; } $array = \preg_split('/' . \preg_quote($pattern, '/') . '/u', $str, $limit); if ($array === false) { return []; } if ($limit > 0 && \count($array) === $limit) { \array_pop($array); } return $array; } public static function str_starts_with(string $haystack, string $needle): bool { if ('' === $haystack || '' === $needle) { return false; } if (\strpos($haystack, $needle) === 0) { return true; } return false; } public static function str_starts_with_any(string $str, array $substrings): bool { if ('' === $str) { return false; } if (empty($substrings)) { return false; } foreach ($substrings as $substring) { if (self::str_starts_with($str, $substring)) { return true; } } return false; } public static function str_substr_after_first_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_index_first($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, $offset + self::strlen($separator, $encoding), null, $encoding ); } public static function str_substr_after_last_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_index_last($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, $offset + self::strlen($separator, $encoding), null, $encoding ); } public static function str_substr_before_first_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_index_first($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, 0, $offset, $encoding ); } public static function str_substr_before_last_separator(string $str, string $separator, string $encoding = 'UTF-8'): string { if ( $separator === '' || $str === '' ) { return ''; } $offset = self::str_index_last($str, $separator); if ($offset === false) { return ''; } return (string)self::substr( $str, 0, $offset, $encoding ); } public static function str_substr_first(string $str, string $needle, bool $beforeNeedle = false, string $encoding = 'UTF-8'): string { if ( '' === $str || '' === $needle ) { return ''; } $part = self::strstr( $str, $needle, $beforeNeedle, $encoding ); if (false === $part) { return ''; } return $part; } public static function str_substr_last(string $str, string $needle, bool $beforeNeedle = false, string $encoding = 'UTF-8'): string { if ( '' === $str || '' === $needle ) { return ''; } $part = self::strrchr($str, $needle, $beforeNeedle, $encoding); if (false === $part) { return ''; } return $part; } public static function str_surround(string $str, string $substring): string { return \implode('', [$substring, $str, $substring]); } public static function str_titleize( string $str, array $ignore = null, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false, bool $useTrimFirst = true ): string { if ($useTrimFirst === true) { $str = self::trim($str); } $str_array = self::str_to_words($str); foreach ($str_array as &$str_tmp) { if ($ignore && \in_array($str_tmp, $ignore, true)) { continue; } $str_tmp = self::str_upper_first( self::strtolower( $str_tmp, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength ), $encoding, $cleanUtf8, $lang, $tryToKeepStringLength ); } return \implode('', $str_array); } public static function str_titleize_for_humans(string $str, array $ignore = [], string $encoding = 'UTF-8'): string { $smallWords = \array_merge( [ '(?<!q&)a', 'an', 'and', 'as', 'at(?!&t)', 'but', 'by', 'en', 'for', 'if', 'in', 'of', 'on', 'or', 'the', 'to', 'v[.]?', 'via', 'vs[.]?', ], $ignore ); $smallWordsRx = \implode('|', $smallWords); $apostropheRx = '(?x: [\'’] [[:lower:]]* )?'; $str = self::trim($str); if (self::has_lowercase($str) === false) { $str = self::strtolower($str); } $str = (string)\preg_replace_callback( '~\b (_*) (?:                                                              # 1. Leading underscore and
                        ( (?<=[ ][/\\\\]) [[:alpha:]]+ [-_[:alpha:]/\\\\]+ |              # 2. file path or 
                          [-_[:alpha:]]+ [@.:] [-_[:alpha:]@.:/]+ ' . $apostropheRx . ' ) #    URL, domain, or email
                        |
                        ( (?i: ' . $smallWordsRx . ' ) ' . $apostropheRx . ' )            # 3. or small word (case-insensitive)
                        |
                        ( [[:alpha:]] [[:lower:]\'’()\[\]{}]* ' . $apostropheRx . ' )     # 4. or word w/o internal caps
                        |
                        ( [[:alpha:]] [[:alpha:]\'’()\[\]{}]* ' . $apostropheRx . ' )     # 5. or some other word
                      ) (_*) \b                                                           # 6. With trailing underscore
                    ~ux', function ($matches) use ($encoding) { $str = $matches[1]; if ($matches[2]) { $str .= $matches[2]; } elseif ($matches[3]) { $str .= self::strtolower($matches[3], $encoding); } elseif ($matches[4]) { $str .= static::str_upper_first($matches[4], $encoding); } else { $str .= $matches[5]; } $str .= $matches[6]; return $str; }, $str ); $str = (string)\preg_replace_callback( '~(  \A [[:punct:]]*                # start of title...
                      |  [:.;?!][ ]+               # or of subsentence...
                      |  [ ][\'"“‘(\[][ ]* )       # or of inserted subphrase...
                      ( ' . $smallWordsRx . ' ) \b # ...followed by small word
                     ~uxi', function ($matches) use ($encoding) { return $matches[1] . static::str_upper_first($matches[2], $encoding); }, $str ); $str = (string)\preg_replace_callback( '~\b ( ' . $smallWordsRx . ' ) # small word...
                      (?= [[:punct:]]* \Z     # ...at the end of the title...
                      |   [\'"’”)\]] [ ] )    # ...or of an inserted subphrase?
                     ~uxi', function ($matches) use ($encoding) { return static::str_upper_first($matches[1], $encoding); }, $str ); $str = (string)\preg_replace_callback( '~\b
                        (?<! -)                   # Negative lookbehind for a hyphen; we do not want to match man-in-the-middle but do want (in-flight)
                        ( ' . $smallWordsRx . ' )
                        (?= -[[:alpha:]]+)        # lookahead for "-someword"
                       ~uxi', function ($matches) use ($encoding) { return static::str_upper_first($matches[1], $encoding); }, $str ); $str = (string)\preg_replace_callback( '~\b
                      (?<!…)                    # Negative lookbehind for a hyphen; we do not want to match man-in-the-middle but do want (stand-in)
                      ( [[:alpha:]]+- )         # $1 = first word and hyphen, should already be properly capped
                      ( ' . $smallWordsRx . ' ) # ...followed by small word
                      (?!	- )                   # Negative lookahead for another -
                     ~uxi', function ($matches) use ($encoding) { return $matches[1] . static::str_upper_first($matches[2], $encoding); }, $str ); return $str; } public static function str_to_binary(string $str): string { $value = \unpack('H*', $str); return \base_convert($value[1], 16, 2); } public static function str_to_lines(string $str, bool $removeEmptyValues = false, int $removeShortValues = null): array { if ('' === $str) { return ($removeEmptyValues === true ? [] : ['']); } $return = \preg_split("/[\r\n]{1,2}/u", $str); if ($return === false) { return ($removeEmptyValues === true ? [] : ['']); } if ( $removeShortValues === null && $removeEmptyValues === false ) { return $return; } $tmpReturn = self::reduce_string_array( $return, $removeEmptyValues, $removeShortValues ); return $tmpReturn; } public static function str_to_words(string $str, string $charList = '', bool $removeEmptyValues = false, int $removeShortValues = null): array { if ('' === $str) { return ($removeEmptyValues === true ? [] : ['']); } $charList = self::rxClass($charList, '\pL'); $return = \preg_split("/({$charList}+(?:[\p{Pd}’']{$charList}+)*)/u", $str, -1, PREG_SPLIT_DELIM_CAPTURE); if ($return === false) { return ($removeEmptyValues === true ? [] : ['']); } if ( $removeShortValues === null && $removeEmptyValues === false ) { return $return; } $tmpReturn = self::reduce_string_array( $return, $removeEmptyValues, $removeShortValues ); foreach ($tmpReturn as &$item) { $item = (string)$item; } return $tmpReturn; } public static function str_transliterate(string $str, string $unknown = '?', bool $strict = false): string { return self::to_ascii($str, $unknown, $strict); } public static function str_truncate($str, int $length, string $substring = '', string $encoding = 'UTF-8'): string { $str = (string)$str; if ('' === $str) { return ''; } if ($length >= self::strlen($str, $encoding)) { return $str; } $substringLength = self::strlen($substring, $encoding); $length -= $substringLength; $truncated = self::substr($str, 0, $length, $encoding); return $truncated . $substring; } public static function str_truncate_safe(string $str, int $length, string $substring = '', string $encoding = 'UTF-8'): string { if ($length >= self::strlen($str, $encoding)) { return $str; } $substringLength = self::strlen($substring, $encoding); $length -= $substringLength; $truncated = self::substr($str, 0, $length, $encoding); if ($truncated === false) { return ''; } $strPosSpace = self::strpos($str, ' ', $length - 1, $encoding); if ($strPosSpace != $length) { $lastPos = self::strrpos($truncated, ' ', 0, $encoding); if ($lastPos !== false || $strPosSpace !== false) { $truncated = self::substr($truncated, 0, (int)$lastPos, $encoding); } } $str = $truncated . $substring; return $str; } public static function str_underscored(string $str): string { return self::str_delimit($str, '_'); } public static function str_upper_camelize(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { return self::str_upper_first(self::str_camelize($str, $encoding), $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } public static function str_upper_first(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { return self::ucfirst($str, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength); } public static function str_word_count(string $str, int $format = 0, string $charlist = '') { $strParts = self::str_to_words($str, $charlist); $len = \count($strParts); if ($format === 1) { $numberOfWords = []; for ($i = 1; $i < $len; $i += 2) { $numberOfWords[] = $strParts[$i]; } } elseif ($format === 2) { $numberOfWords = []; $offset = self::strlen($strParts[0]); for ($i = 1; $i < $len; $i += 2) { $numberOfWords[$offset] = $strParts[$i]; $offset += self::strlen($strParts[$i]) + self::strlen($strParts[$i + 1]); } } else { $numberOfWords = (int)(($len - 1) / 2); } return $numberOfWords; } public static function strcasecmp(string $str1, string $str2, string $encoding = 'UTF-8'): int { return self::strcmp( self::strtocasefold($str1, true, false, $encoding, null, false), self::strtocasefold($str2, true, false, $encoding, null, false) ); } public static function strchr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { return self::strstr($haystack, $needle, $before_needle, $encoding, $cleanUtf8); } public static function strcmp(string $str1, string $str2): int { return $str1 . '' === $str2 . '' ? 0 : \strcmp( \Normalizer::normalize($str1, \Normalizer::NFD), \Normalizer::normalize($str2, \Normalizer::NFD) ); } public static function strcspn(string $str, string $charList, int $offset = 0, int $length = null) { if ('' === $charList .= '') { return null; } if ($offset || $length !== null) { $strTmp = self::substr($str, $offset, $length); if ($strTmp === false) { return null; } $str = (string)$strTmp; } if ('' === $str) { return null; } if (\preg_match('/^(.*?)' . self::rxClass($charList) . '/us', $str, $length)) { return self::strlen($length[1]); } return self::strlen($str); } public static function strichr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { return self::stristr($haystack, $needle, $before_needle, $encoding, $cleanUtf8); } public static function string(array $array): string { return \implode( '', \array_map( [ self::class, 'chr', ], $array ) ); } public static function string_has_bom(string $str): bool { foreach (self::$BOM as $bomString => $bomByteLength) { if (0 === \strpos($str, $bomString)) { return true; } } return false; } public static function strip_tags(string $str, string $allowable_tags = null, bool $cleanUtf8 = false): string { if ('' === $str) { return ''; } if ($cleanUtf8 === true) { $str = self::clean($str); } return \strip_tags($str, $allowable_tags); } public static function strip_whitespace(string $str): string { if ('' === $str) { return ''; } return (string)\preg_replace('/[[:space:]]+/u', '', $str); } public static function stripos(string $haystack, string $needle, int $offset = 0, $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack || '' === $needle) { return false; } if ($cleanUtf8 === true) { $haystack = self::clean($haystack); $needle = self::clean($needle); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $returnTmp = \mb_stripos($haystack, $needle, $offset, $encoding); if ($returnTmp !== false) { return $returnTmp; } } if ( $encoding === 'UTF-8' && $offset >= 0 && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_stripos($haystack, $needle, $offset); if ($returnTmp !== false) { return $returnTmp; } } if (self::is_ascii($haystack) && self::is_ascii($needle)) { return \stripos($haystack, $needle, $offset); } $haystack = self::strtocasefold($haystack, true, false, $encoding, null, false); $needle = self::strtocasefold($needle, true, false, $encoding, null, false); return self::strpos($haystack, $needle, $offset, $encoding); } public static function stristr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack || '' === $needle) { return false; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if (!$needle) { return $haystack; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::stristr() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_stristr($haystack, $needle, $before_needle, $encoding); } if ( $encoding === 'UTF-8' && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_stristr($haystack, $needle, $before_needle); if ($returnTmp !== false) { return $returnTmp; } } if (self::is_ascii($needle) && self::is_ascii($haystack)) { return \stristr($haystack, $needle, $before_needle); } \preg_match('/^(.*?)' . \preg_quote($needle, '/') . '/usi', $haystack, $match); if (!isset($match[1])) { return false; } if ($before_needle) { return $match[1]; } return self::substr($haystack, self::strlen($match[1])); } public static function strlen(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $str) { return 0; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::strlen_in_byte($str); } if ($cleanUtf8 === true) { $str = self::clean($str); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false && self::$SUPPORT['iconv'] === false ) { \trigger_error('UTF8::strlen() without mbstring / iconv cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { $returnTmp = \mb_strlen($str, $encoding); if ($returnTmp !== false) { return $returnTmp; } } if (self::$SUPPORT['iconv'] === true) { $returnTmp = \iconv_strlen($str, $encoding); if ($returnTmp !== false) { return $returnTmp; } } if ( $encoding === 'UTF-8' && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_strlen($str); if ($returnTmp !== null) { return $returnTmp; } } if (self::is_ascii($str)) { return \strlen($str); } \preg_match_all('/./us', $str, $parts); $returnTmp = \count($parts[0]); if ($returnTmp === 0 && isset($str[0])) { return false; } return $returnTmp; } public static function strlen_in_byte(string $str): int { if ($str === '') { return 0; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_strlen($str, 'CP850'); } return \strlen($str); } public static function strnatcasecmp(string $str1, string $str2, string $encoding = 'UTF-8'): int { return self::strnatcmp( self::strtocasefold($str1, true, false, $encoding, null, false), self::strtocasefold($str2, true, false, $encoding, null, false) ); } public static function strnatcmp(string $str1, string $str2): int { return $str1 . '' === $str2 . '' ? 0 : \strnatcmp(self::strtonatfold($str1), self::strtonatfold($str2)); } public static function strncasecmp(string $str1, string $str2, int $len, string $encoding = 'UTF-8'): int { return self::strncmp( self::strtocasefold($str1, true, false, $encoding, null, false), self::strtocasefold($str2, true, false, $encoding, null, false), $len ); } public static function strncmp(string $str1, string $str2, int $len): int { $str1 = (string)self::substr($str1, 0, $len); $str2 = (string)self::substr($str2, 0, $len); return self::strcmp($str1, $str2); } public static function strpbrk(string $haystack, string $char_list) { if ('' === $haystack || '' === $char_list) { return false; } if (\preg_match('/' . self::rxClass($char_list) . '/us', $haystack, $m)) { return \substr($haystack, (int)\strpos($haystack, $m[0])); } return false; } public static function strpos(string $haystack, $needle, int $offset = 0, $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack) { return false; } if ((int)$needle === $needle && $needle >= 0) { $needle = (string)self::chr($needle); } $needle = (string)$needle; if ('' === $needle) { return false; } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::strpos_in_byte($haystack, $needle, $offset); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['iconv'] === false && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::strpos() without mbstring / iconv cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { $returnTmp = \mb_strpos($haystack, $needle, $offset, $encoding); if ($returnTmp !== false) { return $returnTmp; } } if ( $encoding === 'UTF-8' && $offset >= 0 && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_strpos($haystack, $needle, $offset); if ($returnTmp !== false) { return $returnTmp; } } if ( $offset >= 0 && self::$SUPPORT['iconv'] === true ) { $returnTmp = \iconv_strpos($haystack, $needle, $offset > 0 ? $offset : 0, $encoding); if ($returnTmp !== false) { return $returnTmp; } } if (($haystackIsAscii = self::is_ascii($haystack)) && self::is_ascii($needle)) { return \strpos($haystack, $needle, $offset); } if ($haystackIsAscii) { $haystackTmp = \substr($haystack, $offset); } else { $haystackTmp = self::substr($haystack, $offset, null, $encoding); } if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; if ($offset < 0) { $offset = 0; } $pos = \strpos($haystack, $needle); if ($pos === false) { return false; } if ($pos) { return ($offset + (self::strlen(substr($haystack, 0, $pos), $encoding))); } return ($offset + 0); } public static function strpos_in_byte(string $haystack, string $needle, int $offset = 0) { if ($haystack === '' || $needle === '') { return false; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_strpos($haystack, $needle, $offset, 'CP850'); } return \strpos($haystack, $needle, $offset); } public static function strrchr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack || '' === $needle) { return false; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::strrchr() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strrchr($haystack, $needle, $before_needle, $encoding); } if ( $before_needle === false && ( $encoding === 'CP850' || $encoding === 'ASCII' ) ) { return \strrchr($haystack, $needle); } if (self::$SUPPORT['iconv'] === true) { $needleTmp = self::substr($needle, 0, 1, $encoding); if ($needleTmp === false) { return false; } $needle = (string)$needleTmp; $pos = \iconv_strrpos($haystack, $needle, $encoding); if (false === $pos) { return false; } if ($before_needle) { return self::substr($haystack, 0, $pos, $encoding); } return self::substr($haystack, $pos, null, $encoding); } $needleTmp = self::substr($needle, 0, 1, $encoding); if ($needleTmp === false) { return false; } $needle = (string)$needleTmp; $pos = self::strrpos($haystack, $needle, null, $encoding); if ($pos === false) { return false; } if ($before_needle) { return self::substr($haystack, 0, $pos, $encoding); } return self::substr($haystack, $pos, null, $encoding); } public static function strrev(string $str): string { if ('' === $str) { return ''; } $reversed = ''; $i = self::strlen($str); while ($i--) { $reversed .= self::substr($str, $i, 1); } return $reversed; } public static function strrichr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack || '' === $needle) { return false; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strrichr($haystack, $needle, $before_needle, $encoding); } $needleTmp = self::substr($needle, 0, 1, $encoding); if ($needleTmp === false) { return false; } $needle = (string)$needleTmp; $pos = self::strripos($haystack, $needle, 0, $encoding); if ($pos === false) { return false; } if ($before_needle) { return self::substr($haystack, 0, $pos, $encoding); } return self::substr($haystack, $pos, null, $encoding); } public static function strripos(string $haystack, $needle, int $offset = 0, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack) { return false; } if ((int)$needle === $needle && $needle >= 0) { $needle = (string)self::chr($needle); } $needle = (string)$needle; if ('' === $needle) { return false; } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::strripos_in_byte($haystack, $needle, $offset); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::strripos() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strripos($haystack, $needle, $offset, $encoding); } if ( $encoding === 'UTF-8' && $offset >= 0 && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_strripos($haystack, $needle, $offset); if ($returnTmp !== false) { return $returnTmp; } } if (self::is_ascii($haystack) && self::is_ascii($needle)) { return self::strripos_in_byte($haystack, $needle, $offset); } $haystack = self::strtocasefold($haystack, true, false, $encoding); $needle = self::strtocasefold($needle, true, false, $encoding); return self::strrpos($haystack, $needle, $offset, $encoding, $cleanUtf8); } public static function strripos_in_byte(string $haystack, string $needle, int $offset = 0) { if ($haystack === '' || $needle === '') { return false; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_strripos($haystack, $needle, $offset, 'CP850'); } return \strripos($haystack, $needle, $offset); } public static function strrpos(string $haystack, $needle, int $offset = null, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $haystack) { return false; } if ((int)$needle === $needle && $needle >= 0) { $needle = (string)self::chr($needle); } $needle = (string)$needle; if ('' === $needle) { return false; } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::strrpos_in_byte($haystack, $needle, $offset); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::strrpos() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strrpos($haystack, $needle, $offset, $encoding); } if ( $offset !== null && $offset >= 0 && $encoding === 'UTF-8' && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_strrpos($haystack, $needle, $offset); if ($returnTmp !== false) { return $returnTmp; } } if ( $offset !== null && self::is_ascii($haystack) && self::is_ascii($needle) ) { return self::strrpos_in_byte($haystack, $needle, $offset); } $haystackTmp = null; if ($offset > 0) { $haystackTmp = self::substr($haystack, $offset); } elseif ($offset < 0) { $haystackTmp = self::substr($haystack, 0, $offset); $offset = 0; } if ($haystackTmp !== null) { if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } $pos = self::strrpos_in_byte($haystack, $needle); if ($pos === false) { return false; } return $offset + self::strlen(self::substr_in_byte($haystack, 0, $pos)); } public static function strrpos_in_byte(string $haystack, string $needle, int $offset = 0) { if ($haystack === '' || $needle === '') { return false; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_strrpos($haystack, $needle, $offset, 'CP850'); } return \strrpos($haystack, $needle, $offset); } public static function strspn(string $str, string $mask, int $offset = 0, int $length = null): int { if ($offset || $length !== null) { $strTmp = self::substr($str, $offset, $length); if ($strTmp === false) { $strTmp = ''; } $str = (string)$strTmp; } if ('' === $str || '' === $mask) { return 0; } return \preg_match('/^' . self::rxClass($mask) . '+/u', $str, $str) ? self::strlen($str[0]) : 0; } public static function strstr(string $haystack, string $needle, bool $before_needle = false, string $encoding = 'UTF-8', $cleanUtf8 = false) { if ('' === $haystack || '' === $needle) { return false; } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::strstr_in_byte($haystack, $needle, $before_needle); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::strstr() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strstr($haystack, $needle, $before_needle, $encoding); } if ( $encoding === 'UTF-8' && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_strstr($haystack, $needle, $before_needle); if ($returnTmp !== false) { return $returnTmp; } } if (self::is_ascii($haystack) && self::is_ascii($needle)) { return self::strstr_in_byte($haystack, $needle, $before_needle); } \preg_match('/^(.*?)' . \preg_quote($needle, '/') . '/us', $haystack, $match); if (!isset($match[1])) { return false; } if ($before_needle) { return $match[1]; } return self::substr($haystack, self::strlen($match[1])); } public static function strstr_in_byte(string $haystack, string $needle, bool $before_needle = false) { if ($haystack === '' || $needle === '') { return false; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_strstr($haystack, $needle, $before_needle, 'CP850'); } return \strstr($haystack, $needle, $before_needle); } public static function strtocasefold( string $str, bool $full = true, bool $cleanUtf8 = false, string $encoding = 'UTF-8', string $lang = null, $lower = true ): string { if ('' === $str) { return ''; } $str = self::fixStrCaseHelper($str, $lower, $full); if ($lower === true) { return self::strtolower($str, $encoding, $cleanUtf8, $lang); } return self::strtoupper($str, $encoding, $cleanUtf8, $lang); } public static function strtolower($str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { $str = (string)$str; if ('' === $str) { return ''; } if ($cleanUtf8 === true) { $str = self::clean($str); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($tryToKeepStringLength === true) { $str = self::fixStrCaseHelper($str, true); } if ($lang !== null) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['intl'] === true) { $langCode = $lang . '-Lower'; if (!\in_array($langCode, self::$SUPPORT['intl__transliterator_list_ids'], true)) { \trigger_error('UTF8::strtolower() cannot handle special language: ' . $lang, E_USER_WARNING); $langCode = 'Any-Lower'; } return transliterator_transliterate($langCode, $str); } \trigger_error('UTF8::strtolower() without intl cannot handle the "lang" parameter: ' . $lang, E_USER_WARNING); } return \mb_strtolower($str, $encoding); } private static function strtonatfold(string $str): string { return \preg_replace('/\p{Mn}+/u', '', \Normalizer::normalize($str, \Normalizer::NFD)); } public static function strtoupper($str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { $str = (string)$str; if ('' === $str) { return ''; } if ($cleanUtf8 === true) { $str = self::clean($str); } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($tryToKeepStringLength === true) { $str = self::fixStrCaseHelper($str, false); } if ($lang !== null) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['intl'] === true) { $langCode = $lang . '-Upper'; if (!\in_array($langCode, self::$SUPPORT['intl__transliterator_list_ids'], true)) { \trigger_error('UTF8::strtoupper() without intl for special language: ' . $lang, E_USER_WARNING); $langCode = 'Any-Upper'; } return transliterator_transliterate($langCode, $str); } \trigger_error('UTF8::strtolower() without intl + PHP >= 5.4 cannot handle the "lang"-parameter: ' . $lang, E_USER_WARNING); } return \mb_strtoupper($str, $encoding); } public static function strtr(string $str, $from, $to = INF): string { if ('' === $str) { return ''; } if ($from === $to) { return $str; } if (INF !== $to) { $from = self::str_split($from); $to = self::str_split($to); $countFrom = \count($from); $countTo = \count($to); if ($countFrom > $countTo) { $from = \array_slice($from, 0, $countTo); } elseif ($countFrom < $countTo) { $to = \array_slice($to, 0, $countFrom); } $from = \array_combine($from, $to); } if (\is_string($from)) { return \str_replace($from, '', $str); } return \strtr($str, $from); } public static function strwidth(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false): int { if ('' === $str) { return 0; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $str = self::clean($str); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { return \mb_strwidth($str, $encoding); } if ('UTF-8' !== $encoding) { $str = self::encode('UTF-8', $str, false, $encoding); } $wide = 0; $str = (string)preg_replace('/[\x{1100}-\x{115F}\x{2329}\x{232A}\x{2E80}-\x{303E}\x{3040}-\x{A4CF}\x{AC00}-\x{D7A3}\x{F900}-\x{FAFF}\x{FE10}-\x{FE19}\x{FE30}-\x{FE6F}\x{FF00}-\x{FF60}\x{FFE0}-\x{FFE6}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}]/u', '', $str, -1, $wide); return ($wide << 1) + self::strlen($str, 'UTF-8'); } public static function substr(string $str, int $offset = 0, int $length = null, string $encoding = 'UTF-8', bool $cleanUtf8 = false) { if ('' === $str) { return ''; } if ($length === 0) { return ''; } if ($cleanUtf8 === true) { $str = self::clean($str); } if (!$offset && $length === null) { return $str; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding === 'CP850' || $encoding === 'ASCII' ) { return self::substr_in_byte($str, $offset, $length); } if (self::$SUPPORT['mbstring'] === true) { $return = \mb_substr($str, $offset, $length ?? 2147483647, $encoding); if ($return !== false) { return $return; } } $str_length = 0; if ($offset || $length === null) { $str_length = self::strlen($str, $encoding); } if ($str_length === false) { return false; } if ($offset === $str_length && !$length) { return ''; } if ($offset && $offset > $str_length) { return ''; } if ($length === null) { $length = (int)$str_length; } else { $length = (int)$length; } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::substr() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if ( $encoding === 'UTF-8' && $offset >= 0 && self::$SUPPORT['intl'] === true ) { $returnTmp = \grapheme_substr($str, $offset, $length); if ($returnTmp !== false) { return $returnTmp; } } if ( $length >= 0 && self::$SUPPORT['iconv'] === true ) { $returnTmp = \iconv_substr($str, $offset, $length); if ($returnTmp !== false) { return $returnTmp; } } if (self::is_ascii($str)) { return \substr($str, $offset, $length); } $array = self::split($str); return \implode('', \array_slice($array, $offset, $length)); } public static function substr_compare(string $str1, string $str2, int $offset = 0, int $length = null, bool $case_insensitivity = false): int { if ( $offset !== 0 || $length !== null ) { $str1Tmp = self::substr($str1, $offset, $length); if ($str1Tmp === false) { $str1Tmp = ''; } $str1 = (string)$str1Tmp; $str2Tmp = self::substr($str2, 0, self::strlen($str1)); if ($str2Tmp === false) { $str2Tmp = ''; } $str2 = (string)$str2Tmp; } if ($case_insensitivity === true) { return self::strcasecmp($str1, $str2); } return self::strcmp($str1, $str2); } public static function substr_count( string $haystack, string $needle, int $offset = 0, int $length = null, string $encoding = 'UTF-8', bool $cleanUtf8 = false ) { if ('' === $haystack || '' === $needle) { return false; } if ($offset || $length !== null) { if ($length === null) { $lengthTmp = self::strlen($haystack); if ($lengthTmp === false) { return false; } $length = (int)$lengthTmp; } if ( ( $length !== 0 && $offset !== 0 ) && ($length + $offset) <= 0 && Bootup::is_php('7.1') === false ) { return false; } $haystackTmp = self::substr($haystack, $offset, $length, $encoding); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $needle = self::clean($needle); $haystack = self::clean($haystack); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( $encoding !== 'UTF-8' && self::$SUPPORT['mbstring'] === false ) { \trigger_error('UTF8::substr_count() without mbstring cannot handle "' . $encoding . '" encoding', E_USER_WARNING); } if (self::$SUPPORT['mbstring'] === true) { return \mb_substr_count($haystack, $needle, $encoding); } \preg_match_all('/' . \preg_quote($needle, '/') . '/us', $haystack, $matches, PREG_SET_ORDER); return \count($matches); } public static function substr_count_in_byte(string $haystack, string $needle, int $offset = 0, int $length = null) { if ($haystack === '' || $needle === '') { return 0; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if ( ($offset || $length !== null) && self::$SUPPORT['mbstring_func_overload'] === true ) { if ($length === null) { $lengthTmp = self::strlen($haystack); if ($lengthTmp === false) { return false; } $length = (int)$lengthTmp; } if ( ( $length !== 0 && $offset !== 0 ) && ($length + $offset) <= 0 && Bootup::is_php('7.1') === false ) { return false; } $haystackTmp = self::substr_in_byte($haystack, $offset, $length); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_substr_count($haystack, $needle, 'CP850'); } return \substr_count($haystack, $needle, $offset, $length); } public static function substr_count_simple(string $str, string $substring, $caseSensitive = true, string $encoding = 'UTF-8'): int { if ('' === $str || '' === $substring) { return 0; } if ($caseSensitive !== false && $caseSensitive !== true) { $encoding = (string)$caseSensitive; } if (!$caseSensitive) { $str = self::strtocasefold($str, true, false, $encoding, null, false); $substring = self::strtocasefold($substring, true, false, $encoding, null, false); } return (int)self::substr_count($str, $substring, 0, null, $encoding); } public static function substr_ileft(string $haystack, string $needle): string { if ('' === $haystack) { return ''; } if ('' === $needle) { return $haystack; } if (self::str_istarts_with($haystack, $needle) === true) { $haystackTmp = self::substr($haystack, self::strlen($needle)); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } return $haystack; } public static function substr_in_byte(string $str, int $offset = 0, int $length = null) { if ($str === '') { return ''; } if ($length === 0) { return ''; } if (!$offset && $length === null) { return $str; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring_func_overload'] === true) { return \mb_substr($str, $offset, $length ?? 2147483647, 'CP850'); } return \substr($str, $offset, $length ?? 2147483647); } public static function substr_iright(string $haystack, string $needle): string { if ('' === $haystack) { return ''; } if ('' === $needle) { return $haystack; } if (self::str_iends_with($haystack, $needle) === true) { $haystackTmp = self::substr($haystack, 0, self::strlen($haystack) - self::strlen($needle)); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } return $haystack; } public static function substr_left(string $haystack, string $needle): string { if ('' === $haystack) { return ''; } if ('' === $needle) { return $haystack; } if (self::str_starts_with($haystack, $needle) === true) { $haystackTmp = self::substr($haystack, self::strlen($needle)); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } return $haystack; } public static function substr_replace($str, $replacement, $offset, $length = null, string $encoding = 'UTF-8') { if (\is_array($str) === true) { $num = \count($str); if (\is_array($replacement) === true) { $replacement = \array_slice($replacement, 0, $num); } else { $replacement = \array_pad([$replacement], $num, $replacement); } if (\is_array($offset) === true) { $offset = \array_slice($offset, 0, $num); foreach ($offset as &$valueTmp) { $valueTmp = (int)$valueTmp === $valueTmp ? $valueTmp : 0; } unset($valueTmp); } else { $offset = \array_pad([$offset], $num, $offset); } if (null === $length) { $length = \array_fill(0, $num, 0); } elseif (\is_array($length) === true) { $length = \array_slice($length, 0, $num); foreach ($length as &$valueTmpV2) { if (null !== $valueTmpV2) { $valueTmpV2 = (int)$valueTmpV2 === $valueTmpV2 ? $valueTmpV2 : $num; } else { $valueTmpV2 = 0; } } unset($valueTmpV2); } else { $length = \array_pad([$length], $num, $length); } return \array_map([self::class, 'substr_replace'], $str, $replacement, $offset, $length); } if (\is_array($replacement) === true) { if (\count($replacement) > 0) { $replacement = $replacement[0]; } else { $replacement = ''; } } $str = (string)$str; $replacement = (string)$replacement; if ('' === $str) { return $replacement; } if (self::is_ascii($str)) { return ($length === null) ? \substr_replace($str, $replacement, $offset) : \substr_replace($str, $replacement, $offset, $length); } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['mbstring'] === true) { $string_length = self::strlen($str, $encoding); if ($offset < 0) { $offset = \max(0, $string_length + $offset); } elseif ($offset > $string_length) { $offset = $string_length; } if ($length < 0) { $length = \max(0, $string_length - $offset + $length); } elseif ($length === null || $length > $string_length) { $length = $string_length; } if (($offset + $length) > $string_length) { $length = $string_length - $offset; } return self::substr($str, 0, $offset, $encoding) . $replacement . self::substr($str, $offset + $length, $string_length - $offset - $length, $encoding); } \preg_match_all('/./us', $str, $smatches); \preg_match_all('/./us', $replacement, $rmatches); if ($length === null) { $lengthTmp = self::strlen($str, $encoding); if ($lengthTmp === false) { return ''; } $length = (int)$lengthTmp; } \array_splice($smatches[0], $offset, $length, $rmatches[0]); return \implode('', $smatches[0]); } public static function substr_right(string $haystack, string $needle): string { if ('' === $haystack) { return ''; } if ('' === $needle) { return $haystack; } if (self::str_ends_with($haystack, $needle) === true) { $haystackTmp = self::substr($haystack, 0, self::strlen($haystack) - self::strlen($needle)); if ($haystackTmp === false) { $haystackTmp = ''; } $haystack = (string)$haystackTmp; } return $haystack; } public static function swapCase(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false): string { if ('' === $str) { return ''; } if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } if ($cleanUtf8 === true) { $str = self::clean($str); } return (string)(self::strtolower($str, $encoding) ^ self::strtoupper($str, $encoding) ^ $str); } public static function symfony_polyfill_used(): bool { $return = false; $returnTmp = \extension_loaded('mbstring') ? true : false; if ($returnTmp === false && \function_exists('mb_strlen')) { $return = true; } $returnTmp = \extension_loaded('iconv') ? true : false; if ($returnTmp === false && \function_exists('iconv')) { $return = true; } return $return; } public static function tabs_to_spaces(string $str, int $tabLength = 4): string { return \str_replace("\t", \str_repeat(' ', $tabLength), $str); } public static function titlecase(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { if ($encoding !== 'UTF-8' && $encoding !== 'CP850') { $encoding = self::normalize_encoding($encoding, 'UTF-8'); } return self::str_titleize($str, null, $encoding, $cleanUtf8, $lang, $tryToKeepStringLength, false); } public static function toAscii(string $str, string $subst_chr = '?', bool $strict = false): string { return self::to_ascii($str, $subst_chr, $strict); } public static function toIso8859($str) { return self::to_iso8859($str); } public static function toLatin1($str) { return self::to_latin1($str); } public static function toUTF8($str) { return self::to_utf8($str); } public static function to_ascii(string $str, string $unknown = '?', bool $strict = false): string { static $UTF8_TO_ASCII; if ('' === $str) { return ''; } if (self::is_ascii($str) === true) { return $str; } $str = self::clean( $str, true, true, true, false, true, true ); if (self::is_ascii($str) === true) { return $str; } if ($strict === true) { if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } if (self::$SUPPORT['intl'] === true) { $str = \transliterator_transliterate('NFKC; [:Nonspacing Mark:] Remove; NFKC; Any-Latin; Latin-ASCII;', $str); if (self::is_ascii($str) === true) { return $str; } } } if (self::$ORD === null) { self::$ORD = self::getData('ord'); } \preg_match_all('/.{1}|[^\x00]{1,1}$/us', $str, $ar); $chars = $ar[0]; $ord = null; foreach ($chars as &$c) { $ordC0 = self::$ORD[$c[0]]; if ($ordC0 >= 0 && $ordC0 <= 127) { continue; } $ordC1 = self::$ORD[$c[1]]; if ($ordC0 >= 192 && $ordC0 <= 223) { $ord = ($ordC0 - 192) * 64 + ($ordC1 - 128); } if ($ordC0 >= 224) { $ordC2 = self::$ORD[$c[2]]; if ($ordC0 <= 239) { $ord = ($ordC0 - 224) * 4096 + ($ordC1 - 128) * 64 + ($ordC2 - 128); } if ($ordC0 >= 240) { $ordC3 = self::$ORD[$c[3]]; if ($ordC0 <= 247) { $ord = ($ordC0 - 240) * 262144 + ($ordC1 - 128) * 4096 + ($ordC2 - 128) * 64 + ($ordC3 - 128); } if ($ordC0 >= 248) { $ordC4 = self::$ORD[$c[4]]; if ($ordC0 <= 251) { $ord = ($ordC0 - 248) * 16777216 + ($ordC1 - 128) * 262144 + ($ordC2 - 128) * 4096 + ($ordC3 - 128) * 64 + ($ordC4 - 128); } if ($ordC0 >= 252) { $ordC5 = self::$ORD[$c[5]]; if ($ordC0 <= 253) { $ord = ($ordC0 - 252) * 1073741824 + ($ordC1 - 128) * 16777216 + ($ordC2 - 128) * 262144 + ($ordC3 - 128) * 4096 + ($ordC4 - 128) * 64 + ($ordC5 - 128); } } } } } if ($ordC0 === 254 || $ordC0 === 255) { $c = $unknown; continue; } if ($ord === null) { $c = $unknown; continue; } $bank = $ord >> 8; if (!isset($UTF8_TO_ASCII[$bank])) { $UTF8_TO_ASCII[$bank] = self::getData(\sprintf('x%02x', $bank)); if ($UTF8_TO_ASCII[$bank] === false) { $UTF8_TO_ASCII[$bank] = []; } } $newchar = $ord & 255; if (isset($UTF8_TO_ASCII[$bank][$newchar])) { $c = $UTF8_TO_ASCII[$bank][$newchar]; } else { $c = $unknown; } } return \implode('', $chars); } public static function to_boolean($str): bool { $str = (string)$str; if ('' === $str) { return false; } $key = \strtolower($str); $map = [ 'true' => true, '1' => true, 'on' => true, 'yes' => true, 'false' => false, '0' => false, 'off' => false, 'no' => false, ]; if (isset($map[$key])) { return $map[$key]; } if (\is_numeric($str)) { return (((float)$str + 0) > 0); } return (bool)self::trim($str); } public static function to_filename(string $string, bool $use_transliterate = false, string $fallback_char = '-'): string { if ($use_transliterate === true) { $string = self::str_transliterate($string, $fallback_char); } $fallback_char_escaped = \preg_quote($fallback_char, '/'); $string = (string)\preg_replace( [ '/[^' . $fallback_char_escaped . '\.\-a-zA-Z0-9\s]/', '/[\s]+/', '/[' . $fallback_char_escaped . ']+/', ], [ '', $fallback_char, $fallback_char, ], $string ); return \trim($string, $fallback_char); } public static function to_iso8859($str) { if (\is_array($str) === true) { foreach ($str as $k => $v) { $str[$k] = self::to_iso8859($v); } return $str; } $str = (string)$str; if ('' === $str) { return ''; } return self::utf8_decode($str); } public static function to_latin1($str) { return self::to_iso8859($str); } public static function to_utf8($str, bool $decodeHtmlEntityToUtf8 = false) { if (\is_array($str) === true) { foreach ($str as $k => $v) { $str[$k] = self::to_utf8($v, $decodeHtmlEntityToUtf8); } return $str; } $str = (string)$str; if ('' === $str) { return $str; } if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } $max = self::strlen_in_byte($str); $buf = ''; for ($i = 0; $i < $max; $i++) { $c1 = $str[$i]; if ($c1 >= "\xC0") { if ($c1 <= "\xDF") { $c2 = $i + 1 >= $max ? "\x00" : $str[$i + 1]; if ($c2 >= "\x80" && $c2 <= "\xBF") { $buf .= $c1 . $c2; $i++; } else { $buf .= self::to_utf8_convert_helper($c1); } } elseif ($c1 >= "\xE0" && $c1 <= "\xEF") { $c2 = $i + 1 >= $max ? "\x00" : $str[$i + 1]; $c3 = $i + 2 >= $max ? "\x00" : $str[$i + 2]; if ($c2 >= "\x80" && $c2 <= "\xBF" && $c3 >= "\x80" && $c3 <= "\xBF") { $buf .= $c1 . $c2 . $c3; $i += 2; } else { $buf .= self::to_utf8_convert_helper($c1); } } elseif ($c1 >= "\xF0" && $c1 <= "\xF7") { $c2 = $i + 1 >= $max ? "\x00" : $str[$i + 1]; $c3 = $i + 2 >= $max ? "\x00" : $str[$i + 2]; $c4 = $i + 3 >= $max ? "\x00" : $str[$i + 3]; if ($c2 >= "\x80" && $c2 <= "\xBF" && $c3 >= "\x80" && $c3 <= "\xBF" && $c4 >= "\x80" && $c4 <= "\xBF") { $buf .= $c1 . $c2 . $c3 . $c4; $i += 3; } else { $buf .= self::to_utf8_convert_helper($c1); } } else { $buf .= self::to_utf8_convert_helper($c1); } } elseif (($c1 & "\xC0") === "\x80") { $buf .= self::to_utf8_convert_helper($c1); } else { $buf .= $c1; } } $buf = \preg_replace_callback( '/\\\\u([0-9a-f]{4})/i', function ($match) { return \mb_convert_encoding(pack('H*', $match[1]), 'UTF-8', 'UCS-2BE'); }, $buf ); if ($decodeHtmlEntityToUtf8 === true) { $buf = self::html_entity_decode($buf); } return $buf; } private static function to_utf8_convert_helper($input): string { $buf = ''; if (self::$ORD === null) { self::$ORD = self::getData('ord'); } if (self::$CHR === null) { self::$CHR = self::getData('chr'); } if (self::$WIN1252_TO_UTF8 === null) { self::$WIN1252_TO_UTF8 = self::getData('win1252_to_utf8'); } $ordC1 = self::$ORD[$input]; if (isset(self::$WIN1252_TO_UTF8[$ordC1])) { $buf .= self::$WIN1252_TO_UTF8[$ordC1]; } else { $cc1 = self::$CHR[$ordC1 / 64] | "\xC0"; $cc2 = ((string)$input & "\x3F") | "\x80"; $buf .= $cc1 . $cc2; } return $buf; } public static function trim(string $str = '', $chars = INF): string { if ('' === $str) { return ''; } if ($chars === INF || !$chars) { $pattern = "^[\pZ\pC]+|[\pZ\pC]+\$"; } else { $chars = \preg_quote($chars, '/'); $pattern = "^[$chars]+|[$chars]+\$"; } return self::regex_replace($str, $pattern, '', '', '/'); } public static function ucfirst(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false, string $lang = null, bool $tryToKeepStringLength = false): string { if ($cleanUtf8 === true) { $str = self::clean($str); } $strPartTwo = self::substr($str, 1, null, $encoding); if ($strPartTwo === false) { $strPartTwo = ''; } $strPartOne = self::strtoupper( (string)self::substr($str, 0, 1, $encoding), $encoding, $cleanUtf8, $lang, $tryToKeepStringLength ); return $strPartOne . $strPartTwo; } public static function ucword(string $str, string $encoding = 'UTF-8', bool $cleanUtf8 = false): string { return self::ucfirst($str, $encoding, $cleanUtf8); } public static function ucwords(string $str, array $exceptions = [], string $charlist = '', string $encoding = 'UTF-8', bool $cleanUtf8 = false): string { if (!$str) { return ''; } if ($cleanUtf8 === true) { $str = self::clean($str); } $usePhpDefaultFunctions = !(bool)($charlist . \implode('', $exceptions)); if ( $usePhpDefaultFunctions === true && self::is_ascii($str) === true ) { return \ucwords($str); } $words = self::str_to_words($str, $charlist); $newWords = []; if (\count($exceptions) > 0) { $useExceptions = true; } else { $useExceptions = false; } foreach ($words as $word) { if (!$word) { continue; } if ( $useExceptions === false || ( $useExceptions === true && !\in_array($word, $exceptions, true) ) ) { $word = self::ucfirst($word, $encoding); } $newWords[] = $word; } return \implode('', $newWords); } public static function urldecode(string $str, bool $multi_decode = true): string { if ('' === $str) { return ''; } $pattern = '/%u([0-9a-f]{3,4})/i'; if (\preg_match($pattern, $str)) { $str = (string)\preg_replace($pattern, '&#x\\1;', \urldecode($str)); } $flags = ENT_QUOTES | ENT_HTML5; do { $str_compare = $str; $str = self::fix_simple_utf8( \urldecode( self::html_entity_decode( self::to_utf8($str), $flags ) ) ); } while ($multi_decode === true && $str_compare !== $str); return $str; } public static function urldecode_fix_win1252_chars(): array { return [ '%20' => ' ', '%21' => '!', '%22' => '"', '%23' => '#', '%24' => '$', '%25' => '%', '%26' => '&', '%27' => "'", '%28' => '(', '%29' => ')', '%2A' => '*', '%2B' => '+', '%2C' => ',', '%2D' => '-', '%2E' => '.', '%2F' => '/', '%30' => '0', '%31' => '1', '%32' => '2', '%33' => '3', '%34' => '4', '%35' => '5', '%36' => '6', '%37' => '7', '%38' => '8', '%39' => '9', '%3A' => ':', '%3B' => ';', '%3C' => '<', '%3D' => '=', '%3E' => '>', '%3F' => '?', '%40' => '@', '%41' => 'A', '%42' => 'B', '%43' => 'C', '%44' => 'D', '%45' => 'E', '%46' => 'F', '%47' => 'G', '%48' => 'H', '%49' => 'I', '%4A' => 'J', '%4B' => 'K', '%4C' => 'L', '%4D' => 'M', '%4E' => 'N', '%4F' => 'O', '%50' => 'P', '%51' => 'Q', '%52' => 'R', '%53' => 'S', '%54' => 'T', '%55' => 'U', '%56' => 'V', '%57' => 'W', '%58' => 'X', '%59' => 'Y', '%5A' => 'Z', '%5B' => '[', '%5C' => '\\', '%5D' => ']', '%5E' => '^', '%5F' => '_', '%60' => '`', '%61' => 'a', '%62' => 'b', '%63' => 'c', '%64' => 'd', '%65' => 'e', '%66' => 'f', '%67' => 'g', '%68' => 'h', '%69' => 'i', '%6A' => 'j', '%6B' => 'k', '%6C' => 'l', '%6D' => 'm', '%6E' => 'n', '%6F' => 'o', '%70' => 'p', '%71' => 'q', '%72' => 'r', '%73' => 's', '%74' => 't', '%75' => 'u', '%76' => 'v', '%77' => 'w', '%78' => 'x', '%79' => 'y', '%7A' => 'z', '%7B' => '{', '%7C' => '|', '%7D' => '}', '%7E' => '~', '%7F' => '', '%80' => '`', '%81' => '', '%82' => '‚', '%83' => 'ƒ', '%84' => '„', '%85' => '…', '%86' => '†', '%87' => '‡', '%88' => 'ˆ', '%89' => '‰', '%8A' => 'Š', '%8B' => '‹', '%8C' => 'Œ', '%8D' => '', '%8E' => 'Ž', '%8F' => '', '%90' => '', '%91' => '‘', '%92' => '’', '%93' => '“', '%94' => '”', '%95' => '•', '%96' => '–', '%97' => '—', '%98' => '˜', '%99' => '™', '%9A' => 'š', '%9B' => '›', '%9C' => 'œ', '%9D' => '', '%9E' => 'ž', '%9F' => 'Ÿ', '%A0' => '', '%A1' => '¡', '%A2' => '¢', '%A3' => '£', '%A4' => '¤', '%A5' => '¥', '%A6' => '¦', '%A7' => '§', '%A8' => '¨', '%A9' => '©', '%AA' => 'ª', '%AB' => '«', '%AC' => '¬', '%AD' => '', '%AE' => '®', '%AF' => '¯', '%B0' => '°', '%B1' => '±', '%B2' => '²', '%B3' => '³', '%B4' => '´', '%B5' => 'µ', '%B6' => '¶', '%B7' => '·', '%B8' => '¸', '%B9' => '¹', '%BA' => 'º', '%BB' => '»', '%BC' => '¼', '%BD' => '½', '%BE' => '¾', '%BF' => '¿', '%C0' => 'À', '%C1' => 'Á', '%C2' => 'Â', '%C3' => 'Ã', '%C4' => 'Ä', '%C5' => 'Å', '%C6' => 'Æ', '%C7' => 'Ç', '%C8' => 'È', '%C9' => 'É', '%CA' => 'Ê', '%CB' => 'Ë', '%CC' => 'Ì', '%CD' => 'Í', '%CE' => 'Î', '%CF' => 'Ï', '%D0' => 'Ð', '%D1' => 'Ñ', '%D2' => 'Ò', '%D3' => 'Ó', '%D4' => 'Ô', '%D5' => 'Õ', '%D6' => 'Ö', '%D7' => '×', '%D8' => 'Ø', '%D9' => 'Ù', '%DA' => 'Ú', '%DB' => 'Û', '%DC' => 'Ü', '%DD' => 'Ý', '%DE' => 'Þ', '%DF' => 'ß', '%E0' => 'à', '%E1' => 'á', '%E2' => 'â', '%E3' => 'ã', '%E4' => 'ä', '%E5' => 'å', '%E6' => 'æ', '%E7' => 'ç', '%E8' => 'è', '%E9' => 'é', '%EA' => 'ê', '%EB' => 'ë', '%EC' => 'ì', '%ED' => 'í', '%EE' => 'î', '%EF' => 'ï', '%F0' => 'ð', '%F1' => 'ñ', '%F2' => 'ò', '%F3' => 'ó', '%F4' => 'ô', '%F5' => 'õ', '%F6' => 'ö', '%F7' => '÷', '%F8' => 'ø', '%F9' => 'ù', '%FA' => 'ú', '%FB' => 'û', '%FC' => 'ü', '%FD' => 'ý', '%FE' => 'þ', '%FF' => 'ÿ', ]; } public static function utf8_decode(string $str, bool $keepUtf8Chars = false): string { if ('' === $str) { return ''; } static $UTF8_TO_WIN1252_KEYS_CACHE = null; static $UTF8_TO_WIN1252_VALUES_CACHE = null; if ($UTF8_TO_WIN1252_KEYS_CACHE === null) { if (self::$WIN1252_TO_UTF8 === null) { self::$WIN1252_TO_UTF8 = self::getData('win1252_to_utf8'); } $UTF8_TO_WIN1252_KEYS_CACHE = \array_keys(self::$WIN1252_TO_UTF8); $UTF8_TO_WIN1252_VALUES_CACHE = \array_values(self::$WIN1252_TO_UTF8); } $str = \str_replace($UTF8_TO_WIN1252_KEYS_CACHE, $UTF8_TO_WIN1252_VALUES_CACHE, $str); if (!isset(self::$SUPPORT['already_checked_via_portable_utf8'])) { self::checkForSupport(); } $str_backup = $str; $len = self::strlen_in_byte($str); if (self::$ORD === null) { self::$ORD = self::getData('ord'); } if (self::$CHR === null) { self::$CHR = self::getData('chr'); } $noCharFound = '?'; for ($i = 0, $j = 0; $i < $len; ++$i, ++$j) { switch ($str[$i] & "\xF0") { case "\xC0": case "\xD0": $c = (self::$ORD[$str[$i] & "\x1F"] << 6) | self::$ORD[$str[++$i] & "\x3F"]; $str[$j] = $c < 256 ? self::$CHR[$c] : $noCharFound; break; case "\xF0": ++$i; case "\xE0": $str[$j] = $noCharFound; $i += 2; break; default: $str[$j] = $str[$i]; } } $return = self::substr_in_byte($str, 0, $j); if ($return === false) { $return = ''; } if ( $keepUtf8Chars === true && self::strlen($return) >= self::strlen($str_backup) ) { return $str_backup; } return $return; } public static function utf8_encode(string $str): string { if ('' === $str) { return ''; } $str = \utf8_encode($str); if ($str === false) { return ''; } if (false === \strpos($str, "\xC2")) { return $str; } static $WIN1252_TO_UTF8_KEYS_CACHE = null; static $WIN1252_TO_UTF8_VALUES_CACHE = null; if ($WIN1252_TO_UTF8_KEYS_CACHE === null) { if (self::$WIN1252_TO_UTF8 === null) { self::$WIN1252_TO_UTF8 = self::getData('win1252_to_utf8'); } $WIN1252_TO_UTF8_KEYS_CACHE = \array_keys(self::$WIN1252_TO_UTF8); $WIN1252_TO_UTF8_VALUES_CACHE = \array_values(self::$WIN1252_TO_UTF8); } return \str_replace($WIN1252_TO_UTF8_KEYS_CACHE, $WIN1252_TO_UTF8_VALUES_CACHE, $str); } public static function utf8_fix_win1252_chars(string $str): string { return self::fix_simple_utf8($str); } public static function whitespace_table(): array { return self::$WHITESPACE_TABLE; } public static function words_limit(string $str, int $limit = 100, string $strAddOn = '…'): string { if ('' === $str) { return ''; } if ($limit < 1) { return ''; } \preg_match('/^\s*+(?:\S++\s*+){1,' . $limit . '}/u', $str, $matches); if ( !isset($matches[0]) || self::strlen($str) === self::strlen($matches[0]) ) { return $str; } return self::rtrim($matches[0]) . $strAddOn; } public static function wordwrap(string $str, int $width = 75, string $break = "\n", bool $cut = false): string { if ('' === $str || '' === $break) { return ''; } $w = ''; $strSplit = \explode($break, $str); if ($strSplit === false) { $count = 0; } else { $count = \count($strSplit); } $chars = []; for ($i = 0; $i < $count; ++$i) { if ($i) { $chars[] = $break; $w .= '#'; } $c = $strSplit[$i]; unset($strSplit[$i]); if ($c !== null) { foreach (self::split($c) as $c) { $chars[] = $c; $w .= ' ' === $c ? ' ' : '?'; } } } $strReturn = ''; $j = 0; $b = $i = -1; $w = \wordwrap($w, $width, '#', $cut); while (false !== $b = self::strpos($w, '#', $b + 1)) { for (++$i; $i < $b; ++$i) { $strReturn .= $chars[$j]; unset($chars[$j++]); } if ($break === $chars[$j] || ' ' === $chars[$j]) { unset($chars[$j++]); } $strReturn .= $break; } return $strReturn . \implode('', $chars); } public static function wordwrap_per_line(string $str, int $limit): string { $strings = (array)\preg_split('/\\r\\n|\\r|\\n/', $str); $string = ''; foreach ($strings as $value) { if ($value === false) { continue; } $string .= wordwrap($value, $limit); $string .= "\n"; } return $string; } public static function ws(): array { return self::$WHITESPACE; } } 