<?php
 namespace Predis\Command\Processor; use Predis\Command\CommandInterface; use Predis\Command\PrefixableCommandInterface; class KeyPrefixProcessor implements ProcessorInterface { private $prefix; private $commands; public function __construct($prefix) { $this->prefix = $prefix; $this->commands = array( 'EXISTS' => 'static::all', 'DEL' => 'static::all', 'TYPE' => 'static::first', 'KEYS' => 'static::first', 'RENAME' => 'static::all', 'RENAMENX' => 'static::all', 'EXPIRE' => 'static::first', 'EXPIREAT' => 'static::first', 'TTL' => 'static::first', 'MOVE' => 'static::first', 'SORT' => 'static::sort', 'DUMP' => 'static::first', 'RESTORE' => 'static::first', 'SET' => 'static::first', 'SETNX' => 'static::first', 'MSET' => 'static::interleaved', 'MSETNX' => 'static::interleaved', 'GET' => 'static::first', 'MGET' => 'static::all', 'GETSET' => 'static::first', 'INCR' => 'static::first', 'INCRBY' => 'static::first', 'DECR' => 'static::first', 'DECRBY' => 'static::first', 'RPUSH' => 'static::first', 'LPUSH' => 'static::first', 'LLEN' => 'static::first', 'LRANGE' => 'static::first', 'LTRIM' => 'static::first', 'LINDEX' => 'static::first', 'LSET' => 'static::first', 'LREM' => 'static::first', 'LPOP' => 'static::first', 'RPOP' => 'static::first', 'RPOPLPUSH' => 'static::all', 'SADD' => 'static::first', 'SREM' => 'static::first', 'SPOP' => 'static::first', 'SMOVE' => 'static::skipLast', 'SCARD' => 'static::first', 'SISMEMBER' => 'static::first', 'SINTER' => 'static::all', 'SINTERSTORE' => 'static::all', 'SUNION' => 'static::all', 'SUNIONSTORE' => 'static::all', 'SDIFF' => 'static::all', 'SDIFFSTORE' => 'static::all', 'SMEMBERS' => 'static::first', 'SRANDMEMBER' => 'static::first', 'ZADD' => 'static::first', 'ZINCRBY' => 'static::first', 'ZREM' => 'static::first', 'ZRANGE' => 'static::first', 'ZREVRANGE' => 'static::first', 'ZRANGEBYSCORE' => 'static::first', 'ZCARD' => 'static::first', 'ZSCORE' => 'static::first', 'ZREMRANGEBYSCORE' => 'static::first', 'SETEX' => 'static::first', 'APPEND' => 'static::first', 'SUBSTR' => 'static::first', 'BLPOP' => 'static::skipLast', 'BRPOP' => 'static::skipLast', 'ZUNIONSTORE' => 'static::zsetStore', 'ZINTERSTORE' => 'static::zsetStore', 'ZCOUNT' => 'static::first', 'ZRANK' => 'static::first', 'ZREVRANK' => 'static::first', 'ZREMRANGEBYRANK' => 'static::first', 'HSET' => 'static::first', 'HSETNX' => 'static::first', 'HMSET' => 'static::first', 'HINCRBY' => 'static::first', 'HGET' => 'static::first', 'HMGET' => 'static::first', 'HDEL' => 'static::first', 'HEXISTS' => 'static::first', 'HLEN' => 'static::first', 'HKEYS' => 'static::first', 'HVALS' => 'static::first', 'HGETALL' => 'static::first', 'SUBSCRIBE' => 'static::all', 'UNSUBSCRIBE' => 'static::all', 'PSUBSCRIBE' => 'static::all', 'PUNSUBSCRIBE' => 'static::all', 'PUBLISH' => 'static::first', 'PERSIST' => 'static::first', 'STRLEN' => 'static::first', 'SETRANGE' => 'static::first', 'GETRANGE' => 'static::first', 'SETBIT' => 'static::first', 'GETBIT' => 'static::first', 'RPUSHX' => 'static::first', 'LPUSHX' => 'static::first', 'LINSERT' => 'static::first', 'BRPOPLPUSH' => 'static::skipLast', 'ZREVRANGEBYSCORE' => 'static::first', 'WATCH' => 'static::all', 'PTTL' => 'static::first', 'PEXPIRE' => 'static::first', 'PEXPIREAT' => 'static::first', 'PSETEX' => 'static::first', 'INCRBYFLOAT' => 'static::first', 'BITOP' => 'static::skipFirst', 'BITCOUNT' => 'static::first', 'HINCRBYFLOAT' => 'static::first', 'EVAL' => 'static::evalKeys', 'EVALSHA' => 'static::evalKeys', 'MIGRATE' => 'static::migrate', 'SSCAN' => 'static::first', 'ZSCAN' => 'static::first', 'HSCAN' => 'static::first', 'PFADD' => 'static::first', 'PFCOUNT' => 'static::all', 'PFMERGE' => 'static::all', 'ZLEXCOUNT' => 'static::first', 'ZRANGEBYLEX' => 'static::first', 'ZREMRANGEBYLEX' => 'static::first', 'ZREVRANGEBYLEX' => 'static::first', 'BITPOS' => 'static::first', 'HSTRLEN' => 'static::first', 'BITFIELD' => 'static::first', 'GEOADD' => 'static::first', 'GEOHASH' => 'static::first', 'GEOPOS' => 'static::first', 'GEODIST' => 'static::first', 'GEORADIUS' => 'static::georadius', 'GEORADIUSBYMEMBER' => 'static::georadius', ); } public function setPrefix($prefix) { $this->prefix = $prefix; } public function getPrefix() { return $this->prefix; } public function process(CommandInterface $command) { if ($command instanceof PrefixableCommandInterface) { $command->prefixKeys($this->prefix); } elseif (isset($this->commands[$commandID = strtoupper($command->getId())])) { call_user_func($this->commands[$commandID], $command, $this->prefix); } } public function setCommandHandler($commandID, $callback = null) { $commandID = strtoupper($commandID); if (!isset($callback)) { unset($this->commands[$commandID]); return; } if (!is_callable($callback)) { throw new \InvalidArgumentException( 'Callback must be a valid callable object or NULL' ); } $this->commands[$commandID] = $callback; } public function __toString() { return $this->getPrefix(); } public static function first(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $arguments[0] = "$prefix{$arguments[0]}"; $command->setRawArguments($arguments); } } public static function all(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { foreach ($arguments as &$key) { $key = "$prefix$key"; } $command->setRawArguments($arguments); } } public static function interleaved(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $length = count($arguments); for ($i = 0; $i < $length; $i += 2) { $arguments[$i] = "$prefix{$arguments[$i]}"; } $command->setRawArguments($arguments); } } public static function skipFirst(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $length = count($arguments); for ($i = 1; $i < $length; ++$i) { $arguments[$i] = "$prefix{$arguments[$i]}"; } $command->setRawArguments($arguments); } } public static function skipLast(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $length = count($arguments); for ($i = 0; $i < $length - 1; ++$i) { $arguments[$i] = "$prefix{$arguments[$i]}"; } $command->setRawArguments($arguments); } } public static function sort(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $arguments[0] = "$prefix{$arguments[0]}"; if (($count = count($arguments)) > 1) { for ($i = 1; $i < $count; ++$i) { switch (strtoupper($arguments[$i])) { case 'BY': case 'STORE': $arguments[$i] = "$prefix{$arguments[++$i]}"; break; case 'GET': $value = $arguments[++$i]; if ($value !== '#') { $arguments[$i] = "$prefix$value"; } break; case 'LIMIT'; $i += 2; break; } } } $command->setRawArguments($arguments); } } public static function evalKeys(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { for ($i = 2; $i < $arguments[1] + 2; ++$i) { $arguments[$i] = "$prefix{$arguments[$i]}"; } $command->setRawArguments($arguments); } } public static function zsetStore(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $arguments[0] = "$prefix{$arguments[0]}"; $length = ((int) $arguments[1]) + 2; for ($i = 2; $i < $length; ++$i) { $arguments[$i] = "$prefix{$arguments[$i]}"; } $command->setRawArguments($arguments); } } public static function migrate(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $arguments[2] = "$prefix{$arguments[2]}"; $command->setRawArguments($arguments); } } public static function georadius(CommandInterface $command, $prefix) { if ($arguments = $command->getArguments()) { $arguments[0] = "$prefix{$arguments[0]}"; $startIndex = $command->getId() === 'GEORADIUS' ? 5 : 4; if (($count = count($arguments)) > $startIndex) { for ($i = $startIndex; $i < $count; ++$i) { switch (strtoupper($arguments[$i])) { case 'STORE': case 'STOREDIST': $arguments[$i] = "$prefix{$arguments[++$i]}"; break; } } } $command->setRawArguments($arguments); } } } 