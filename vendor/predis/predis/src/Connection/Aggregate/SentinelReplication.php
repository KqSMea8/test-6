<?php
 namespace Predis\Connection\Aggregate; use Predis\Command\CommandInterface; use Predis\Command\RawCommand; use Predis\CommunicationException; use Predis\Connection\ConnectionException; use Predis\Connection\FactoryInterface as ConnectionFactoryInterface; use Predis\Connection\NodeConnectionInterface; use Predis\Connection\Parameters; use Predis\Replication\ReplicationStrategy; use Predis\Replication\RoleException; use Predis\Response\ErrorInterface as ErrorResponseInterface; use Predis\Response\ServerException; class SentinelReplication implements ReplicationInterface { protected $master; protected $slaves = array(); protected $current; protected $service; protected $connectionFactory; protected $strategy; protected $sentinels = array(); protected $sentinelConnection; protected $sentinelTimeout = 0.100; protected $retryLimit = 20; protected $retryWait = 1000; protected $updateSentinels = false; public function __construct( $service, array $sentinels, ConnectionFactoryInterface $connectionFactory, ReplicationStrategy $strategy = null ) { $this->sentinels = $sentinels; $this->service = $service; $this->connectionFactory = $connectionFactory; $this->strategy = $strategy ?: new ReplicationStrategy(); } public function setSentinelTimeout($timeout) { $this->sentinelTimeout = (float) $timeout; } public function setRetryLimit($retry) { $this->retryLimit = (int) $retry; } public function setRetryWait($seconds) { $this->retryWait = (float) $seconds; } public function setUpdateSentinels($update) { $this->updateSentinels = (bool) $update; } protected function reset() { $this->current = null; } protected function wipeServerList() { $this->reset(); $this->master = null; $this->slaves = array(); } public function add(NodeConnectionInterface $connection) { $alias = $connection->getParameters()->alias; if ($alias === 'master') { $this->master = $connection; } else { $this->slaves[$alias ?: count($this->slaves)] = $connection; } $this->reset(); } public function remove(NodeConnectionInterface $connection) { if ($connection === $this->master) { $this->master = null; $this->reset(); return true; } if (false !== $id = array_search($connection, $this->slaves, true)) { unset($this->slaves[$id]); $this->reset(); return true; } return false; } protected function createSentinelConnection($parameters) { if ($parameters instanceof NodeConnectionInterface) { return $parameters; } if (is_string($parameters)) { $parameters = Parameters::parse($parameters); } if (is_array($parameters)) { $parameters['database'] = null; $parameters['password'] = null; if (!isset($parameters['timeout'])) { $parameters['timeout'] = $this->sentinelTimeout; } } $connection = $this->connectionFactory->create($parameters); return $connection; } public function getSentinelConnection() { if (!$this->sentinelConnection) { if (!$this->sentinels) { throw new \Predis\ClientException('No sentinel server available for autodiscovery.'); } $sentinel = array_shift($this->sentinels); $this->sentinelConnection = $this->createSentinelConnection($sentinel); } return $this->sentinelConnection; } public function updateSentinels() { SENTINEL_QUERY: { $sentinel = $this->getSentinelConnection(); try { $payload = $sentinel->executeCommand( RawCommand::create('SENTINEL', 'sentinels', $this->service) ); $this->sentinels = array(); $this->sentinels[] = $sentinel->getParameters()->toArray(); foreach ($payload as $sentinel) { $this->sentinels[] = array( 'host' => $sentinel[3], 'port' => $sentinel[5], ); } } catch (ConnectionException $exception) { $this->sentinelConnection = null; goto SENTINEL_QUERY; } } } public function querySentinel() { $this->wipeServerList(); $this->updateSentinels(); $this->getMaster(); $this->getSlaves(); } private function handleSentinelErrorResponse(NodeConnectionInterface $sentinel, ErrorResponseInterface $error) { if ($error->getErrorType() === 'IDONTKNOW') { throw new ConnectionException($sentinel, $error->getMessage()); } else { throw new ServerException($error->getMessage()); } } protected function querySentinelForMaster(NodeConnectionInterface $sentinel, $service) { $payload = $sentinel->executeCommand( RawCommand::create('SENTINEL', 'get-master-addr-by-name', $service) ); if ($payload === null) { throw new ServerException('ERR No such master with that name'); } if ($payload instanceof ErrorResponseInterface) { $this->handleSentinelErrorResponse($sentinel, $payload); } return array( 'host' => $payload[0], 'port' => $payload[1], 'alias' => 'master', ); } protected function querySentinelForSlaves(NodeConnectionInterface $sentinel, $service) { $slaves = array(); $payload = $sentinel->executeCommand( RawCommand::create('SENTINEL', 'slaves', $service) ); if ($payload instanceof ErrorResponseInterface) { $this->handleSentinelErrorResponse($sentinel, $payload); } foreach ($payload as $slave) { $flags = explode(',', $slave[9]); if (array_intersect($flags, array('s_down', 'o_down', 'disconnected'))) { continue; } $slaves[] = array( 'host' => $slave[3], 'port' => $slave[5], 'alias' => "slave-$slave[1]", ); } return $slaves; } public function getCurrent() { return $this->current; } public function getMaster() { if ($this->master) { return $this->master; } if ($this->updateSentinels) { $this->updateSentinels(); } SENTINEL_QUERY: { $sentinel = $this->getSentinelConnection(); try { $masterParameters = $this->querySentinelForMaster($sentinel, $this->service); $masterConnection = $this->connectionFactory->create($masterParameters); $this->add($masterConnection); } catch (ConnectionException $exception) { $this->sentinelConnection = null; goto SENTINEL_QUERY; } } return $masterConnection; } public function getSlaves() { if ($this->slaves) { return array_values($this->slaves); } if ($this->updateSentinels) { $this->updateSentinels(); } SENTINEL_QUERY: { $sentinel = $this->getSentinelConnection(); try { $slavesParameters = $this->querySentinelForSlaves($sentinel, $this->service); foreach ($slavesParameters as $slaveParameters) { $this->add($this->connectionFactory->create($slaveParameters)); } } catch (ConnectionException $exception) { $this->sentinelConnection = null; goto SENTINEL_QUERY; } } return array_values($this->slaves ?: array()); } protected function pickSlave() { if ($slaves = $this->getSlaves()) { return $slaves[rand(1, count($slaves)) - 1]; } } private function getConnectionInternal(CommandInterface $command) { if (!$this->current) { if ($this->strategy->isReadOperation($command) && $slave = $this->pickSlave()) { $this->current = $slave; } else { $this->current = $this->getMaster(); } return $this->current; } if ($this->current === $this->master) { return $this->current; } if (!$this->strategy->isReadOperation($command)) { $this->current = $this->getMaster(); } return $this->current; } protected function assertConnectionRole(NodeConnectionInterface $connection, $role) { $role = strtolower($role); $actualRole = $connection->executeCommand(RawCommand::create('ROLE')); if ($role !== $actualRole[0]) { throw new RoleException($connection, "Expected $role but got $actualRole[0] [$connection]"); } } public function getConnection(CommandInterface $command) { $connection = $this->getConnectionInternal($command); if (!$connection->isConnected()) { $expectedRole = $this->strategy->isReadOperation($command) && $this->slaves ? 'slave' : 'master'; $this->assertConnectionRole($connection, $expectedRole); } return $connection; } public function getConnectionById($connectionId) { if ($connectionId === 'master') { return $this->getMaster(); } $this->getSlaves(); if (isset($this->slaves[$connectionId])) { return $this->slaves[$connectionId]; } } public function switchTo($connection) { if (!$connection instanceof NodeConnectionInterface) { $connection = $this->getConnectionById($connection); } if ($connection && $connection === $this->current) { return; } if ($connection !== $this->master && !in_array($connection, $this->slaves, true)) { throw new \InvalidArgumentException('Invalid connection or connection not found.'); } $connection->connect(); if ($this->current) { $this->current->disconnect(); } $this->current = $connection; } public function switchToMaster() { $this->switchTo('master'); } public function switchToSlave() { $connection = $this->pickSlave(); $this->switchTo($connection); } public function isConnected() { return $this->current ? $this->current->isConnected() : false; } public function connect() { if (!$this->current) { if (!$this->current = $this->pickSlave()) { $this->current = $this->getMaster(); } } $this->current->connect(); } public function disconnect() { if ($this->master) { $this->master->disconnect(); } foreach ($this->slaves as $connection) { $connection->disconnect(); } } private function retryCommandOnFailure(CommandInterface $command, $method) { $retries = 0; SENTINEL_RETRY: { try { $response = $this->getConnection($command)->$method($command); } catch (CommunicationException $exception) { $this->wipeServerList(); $exception->getConnection()->disconnect(); if ($retries == $this->retryLimit) { throw $exception; } usleep($this->retryWait * 1000); ++$retries; goto SENTINEL_RETRY; } } return $response; } public function writeRequest(CommandInterface $command) { $this->retryCommandOnFailure($command, __FUNCTION__); } public function readResponse(CommandInterface $command) { return $this->retryCommandOnFailure($command, __FUNCTION__); } public function executeCommand(CommandInterface $command) { return $this->retryCommandOnFailure($command, __FUNCTION__); } public function getReplicationStrategy() { return $this->strategy; } public function __sleep() { return array( 'master', 'slaves', 'service', 'sentinels', 'connectionFactory', 'strategy', ); } } 