<?php
 namespace Predis\Connection\Aggregate; use Predis\ClientException; use Predis\Cluster\RedisStrategy as RedisClusterStrategy; use Predis\Cluster\StrategyInterface; use Predis\Command\CommandInterface; use Predis\Command\RawCommand; use Predis\Connection\ConnectionException; use Predis\Connection\FactoryInterface; use Predis\Connection\NodeConnectionInterface; use Predis\NotSupportedException; use Predis\Response\ErrorInterface as ErrorResponseInterface; class RedisCluster implements ClusterInterface, \IteratorAggregate, \Countable { private $useClusterSlots = true; private $pool = array(); private $slots = array(); private $slotsMap; private $strategy; private $connections; private $retryLimit = 5; public function __construct( FactoryInterface $connections, StrategyInterface $strategy = null ) { $this->connections = $connections; $this->strategy = $strategy ?: new RedisClusterStrategy(); } public function setRetryLimit($retry) { $this->retryLimit = (int) $retry; } public function isConnected() { foreach ($this->pool as $connection) { if ($connection->isConnected()) { return true; } } return false; } public function connect() { if ($connection = $this->getRandomConnection()) { $connection->connect(); } } public function disconnect() { foreach ($this->pool as $connection) { $connection->disconnect(); } } public function add(NodeConnectionInterface $connection) { $this->pool[(string) $connection] = $connection; unset($this->slotsMap); } public function remove(NodeConnectionInterface $connection) { if (false !== $id = array_search($connection, $this->pool, true)) { unset( $this->pool[$id], $this->slotsMap ); $this->slots = array_diff($this->slots, array($connection)); return true; } return false; } public function removeById($connectionID) { if (isset($this->pool[$connectionID])) { unset( $this->pool[$connectionID], $this->slotsMap ); return true; } return false; } public function buildSlotsMap() { $this->slotsMap = array(); foreach ($this->pool as $connectionID => $connection) { $parameters = $connection->getParameters(); if (!isset($parameters->slots)) { continue; } foreach (explode(',', $parameters->slots) as $slotRange) { $slots = explode('-', $slotRange, 2); if (!isset($slots[1])) { $slots[1] = $slots[0]; } $this->setSlots($slots[0], $slots[1], $connectionID); } } return $this->slotsMap; } private function queryClusterNodeForSlotsMap(NodeConnectionInterface $connection) { $retries = 0; $command = RawCommand::create('CLUSTER', 'SLOTS'); RETRY_COMMAND: { try { $response = $connection->executeCommand($command); } catch (ConnectionException $exception) { $connection = $exception->getConnection(); $connection->disconnect(); $this->remove($connection); if ($retries === $this->retryLimit) { throw $exception; } if (!$connection = $this->getRandomConnection()) { throw new ClientException('No connections left in the pool for `CLUSTER SLOTS`'); } ++$retries; goto RETRY_COMMAND; } } return $response; } public function askSlotsMap(NodeConnectionInterface $connection = null) { if (!$connection && !$connection = $this->getRandomConnection()) { return array(); } $this->resetSlotsMap(); $response = $this->queryClusterNodeForSlotsMap($connection); foreach ($response as $slots) { list($start, $end, $master) = $slots; if ($master[0] === '') { $this->setSlots($start, $end, (string) $connection); } else { $this->setSlots($start, $end, "{$master[0]}:{$master[1]}"); } } return $this->slotsMap; } public function resetSlotsMap() { $this->slotsMap = array(); } public function getSlotsMap() { if (!isset($this->slotsMap)) { $this->slotsMap = array(); } return $this->slotsMap; } public function setSlots($first, $last, $connection) { if ($first < 0x0000 || $first > 0x3FFF || $last < 0x0000 || $last > 0x3FFF || $last < $first ) { throw new \OutOfBoundsException( "Invalid slot range for $connection: [$first-$last]." ); } $slots = array_fill($first, $last - $first + 1, (string) $connection); $this->slotsMap = $this->getSlotsMap() + $slots; } protected function guessNode($slot) { if (!$this->pool) { throw new ClientException('No connections available in the pool'); } if (!isset($this->slotsMap)) { $this->buildSlotsMap(); } if (isset($this->slotsMap[$slot])) { return $this->slotsMap[$slot]; } $count = count($this->pool); $index = min((int) ($slot / (int) (16384 / $count)), $count - 1); $nodes = array_keys($this->pool); return $nodes[$index]; } protected function createConnection($connectionID) { $separator = strrpos($connectionID, ':'); return $this->connections->create(array( 'host' => substr($connectionID, 0, $separator), 'port' => substr($connectionID, $separator + 1), )); } public function getConnection(CommandInterface $command) { $slot = $this->strategy->getSlot($command); if (!isset($slot)) { throw new NotSupportedException( "Cannot use '{$command->getId()}' with redis-cluster." ); } if (isset($this->slots[$slot])) { return $this->slots[$slot]; } else { return $this->getConnectionBySlot($slot); } } public function getConnectionBySlot($slot) { if ($slot < 0x0000 || $slot > 0x3FFF) { throw new \OutOfBoundsException("Invalid slot [$slot]."); } if (isset($this->slots[$slot])) { return $this->slots[$slot]; } $connectionID = $this->guessNode($slot); if (!$connection = $this->getConnectionById($connectionID)) { $connection = $this->createConnection($connectionID); $this->pool[$connectionID] = $connection; } return $this->slots[$slot] = $connection; } public function getConnectionById($connectionID) { if (isset($this->pool[$connectionID])) { return $this->pool[$connectionID]; } } protected function getRandomConnection() { if ($this->pool) { return $this->pool[array_rand($this->pool)]; } } protected function move(NodeConnectionInterface $connection, $slot) { $this->pool[(string) $connection] = $connection; $this->slots[(int) $slot] = $connection; } protected function onErrorResponse(CommandInterface $command, ErrorResponseInterface $error) { $details = explode(' ', $error->getMessage(), 2); switch ($details[0]) { case 'MOVED': return $this->onMovedResponse($command, $details[1]); case 'ASK': return $this->onAskResponse($command, $details[1]); default: return $error; } } protected function onMovedResponse(CommandInterface $command, $details) { list($slot, $connectionID) = explode(' ', $details, 2); if (!$connection = $this->getConnectionById($connectionID)) { $connection = $this->createConnection($connectionID); } if ($this->useClusterSlots) { $this->askSlotsMap($connection); } $this->move($connection, $slot); $response = $this->executeCommand($command); return $response; } protected function onAskResponse(CommandInterface $command, $details) { list($slot, $connectionID) = explode(' ', $details, 2); if (!$connection = $this->getConnectionById($connectionID)) { $connection = $this->createConnection($connectionID); } $connection->executeCommand(RawCommand::create('ASKING')); $response = $connection->executeCommand($command); return $response; } private function retryCommandOnFailure(CommandInterface $command, $method) { $failure = false; RETRY_COMMAND: { try { $response = $this->getConnection($command)->$method($command); } catch (ConnectionException $exception) { $connection = $exception->getConnection(); $connection->disconnect(); $this->remove($connection); if ($failure) { throw $exception; } elseif ($this->useClusterSlots) { $this->askSlotsMap(); } $failure = true; goto RETRY_COMMAND; } } return $response; } public function writeRequest(CommandInterface $command) { $this->retryCommandOnFailure($command, __FUNCTION__); } public function readResponse(CommandInterface $command) { return $this->retryCommandOnFailure($command, __FUNCTION__); } public function executeCommand(CommandInterface $command) { $response = $this->retryCommandOnFailure($command, __FUNCTION__); if ($response instanceof ErrorResponseInterface) { return $this->onErrorResponse($command, $response); } return $response; } public function count() { return count($this->pool); } public function getIterator() { if ($this->useClusterSlots) { $slotsmap = $this->getSlotsMap() ?: $this->askSlotsMap(); } else { $slotsmap = $this->getSlotsMap() ?: $this->buildSlotsMap(); } $connections = array(); foreach (array_unique($slotsmap) as $node) { if (!$connection = $this->getConnectionById($node)) { $this->add($connection = $this->createConnection($node)); } $connections[] = $connection; } return new \ArrayIterator($connections); } public function getClusterStrategy() { return $this->strategy; } public function getConnectionFactory() { return $this->connections; } public function useClusterSlots($value) { $this->useClusterSlots = (bool) $value; } } 