<?php
 namespace Predis\PubSub; class DispatcherLoop { private $pubsub; protected $callbacks; protected $defaultCallback; protected $subscriptionCallback; public function __construct(Consumer $pubsub) { $this->callbacks = array(); $this->pubsub = $pubsub; } protected function assertCallback($callable) { if (!is_callable($callable)) { throw new \InvalidArgumentException('The given argument must be a callable object.'); } } public function getPubSubConsumer() { return $this->pubsub; } public function subscriptionCallback($callable = null) { if (isset($callable)) { $this->assertCallback($callable); } $this->subscriptionCallback = $callable; } public function defaultCallback($callable = null) { if (isset($callable)) { $this->assertCallback($callable); } $this->subscriptionCallback = $callable; } public function attachCallback($channel, $callback) { $callbackName = $this->getPrefixKeys().$channel; $this->assertCallback($callback); $this->callbacks[$callbackName] = $callback; $this->pubsub->subscribe($channel); } public function detachCallback($channel) { $callbackName = $this->getPrefixKeys().$channel; if (isset($this->callbacks[$callbackName])) { unset($this->callbacks[$callbackName]); $this->pubsub->unsubscribe($channel); } } public function run() { foreach ($this->pubsub as $message) { $kind = $message->kind; if ($kind !== Consumer::MESSAGE && $kind !== Consumer::PMESSAGE) { if (isset($this->subscriptionCallback)) { $callback = $this->subscriptionCallback; call_user_func($callback, $message); } continue; } if (isset($this->callbacks[$message->channel])) { $callback = $this->callbacks[$message->channel]; call_user_func($callback, $message->payload); } elseif (isset($this->defaultCallback)) { $callback = $this->defaultCallback; call_user_func($callback, $message); } } } public function stop() { $this->pubsub->stop(); } protected function getPrefixKeys() { $options = $this->pubsub->getClient()->getOptions(); if (isset($options->prefix)) { return $options->prefix->getPrefix(); } return ''; } } 