<?php declare(strict_types=1); namespace PhpParser\Lexer; use PhpParser\Error; use PhpParser\ErrorHandler; class Emulative extends \PhpParser\Lexer { const PHP_7_3 = '7.3.0dev'; private $patches; public function startLexing(string $code, ErrorHandler $errorHandler = null) { $this->patches = []; $preparedCode = $this->prepareCode($code); if (null === $preparedCode) { parent::startLexing($code, $errorHandler); return; } $collector = new ErrorHandler\Collecting(); parent::startLexing($preparedCode, $collector); $this->fixupTokens(); $errors = $collector->getErrors(); if (!empty($errors)) { $this->fixupErrors($errors); foreach ($errors as $error) { $errorHandler->handleError($error); } } } private function prepareCode(string $code) { if (version_compare(\PHP_VERSION, self::PHP_7_3, '>=')) { return null; } if (strpos($code, '<<<') === false) { return null; } $flexibleDocStringRegex = <<<'REGEX'
/<<<[ \t]*(['"]?)([a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*)\1\r?\n
(?:.*\r?\n)*?
(?<indentation>\h*)\2(?![a-zA-Z_\x80-\xff])(?<separator>(?:;?[\r\n])?)/x
REGEX;
if (!preg_match_all($flexibleDocStringRegex, $code, $matches, PREG_SET_ORDER|PREG_OFFSET_CAPTURE)) { return null; } $posDelta = 0; foreach ($matches as $match) { $indentation = $match['indentation'][0]; $indentationStart = $match['indentation'][1]; $separator = $match['separator'][0]; $separatorStart = $match['separator'][1]; if ($indentation === '' && $separator !== '') { continue; } if ($indentation !== '') { $indentationLen = strlen($indentation); $code = substr_replace($code, '', $indentationStart + $posDelta, $indentationLen); $this->patches[] = [$indentationStart + $posDelta, 'add', $indentation]; $posDelta -= $indentationLen; } if ($separator === '') { $code = substr_replace($code, "\n", $separatorStart + $posDelta, 0); $this->patches[] = [$separatorStart + $posDelta, 'remove', "\n"]; $posDelta += 1; } } if (empty($this->patches)) { return null; } return $code; } private function fixupTokens() { assert(count($this->patches) > 0); $patchIdx = 0; list($patchPos, $patchType, $patchText) = $this->patches[$patchIdx]; $pos = 0; for ($i = 0, $c = \count($this->tokens); $i < $c; $i++) { $token = $this->tokens[$i]; if (\is_string($token)) { $pos += \strlen($token); continue; } $len = \strlen($token[1]); $posDelta = 0; while ($patchPos >= $pos && $patchPos < $pos + $len) { $patchTextLen = \strlen($patchText); if ($patchType === 'remove') { if ($patchPos === $pos && $patchTextLen === $len) { array_splice($this->tokens, $i, 1, []); $i--; $c--; } else { $this->tokens[$i][1] = substr_replace( $token[1], '', $patchPos - $pos + $posDelta, $patchTextLen ); $posDelta -= $patchTextLen; } } elseif ($patchType === 'add') { $this->tokens[$i][1] = substr_replace( $token[1], $patchText, $patchPos - $pos + $posDelta, 0 ); $posDelta += $patchTextLen; } else { assert(false); } $patchIdx++; if ($patchIdx >= \count($this->patches)) { return; } list($patchPos, $patchType, $patchText) = $this->patches[$patchIdx]; $token = $this->tokens[$i]; } $pos += $len; } assert(false); } private function fixupErrors(array $errors) { foreach ($errors as $error) { $attrs = $error->getAttributes(); $posDelta = 0; $lineDelta = 0; foreach ($this->patches as $patch) { list($patchPos, $patchType, $patchText) = $patch; if ($patchPos >= $attrs['startFilePos']) { break; } if ($patchType === 'add') { $posDelta += strlen($patchText); $lineDelta += substr_count($patchText, "\n"); } else { $posDelta -= strlen($patchText); $lineDelta -= substr_count($patchText, "\n"); } } $attrs['startFilePos'] += $posDelta; $attrs['endFilePos'] += $posDelta; $attrs['startLine'] += $lineDelta; $attrs['endLine'] += $lineDelta; $error->setAttributes($attrs); } } }